<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js PathTracing Renderer - BVH Debugging</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1">
		<style>

			html, body {
				width: 100%;
				height: 100%;
				font-family: Monospace;
				background-color: #000;
				color: #000;
				margin: 0px;
				overflow: hidden;
			}
			
			#info {
				position: absolute;
				top: 5px;
				width: 100%;
				text-align: center;
				color: #ffffff;
			}		
			
		</style>
	</head>
	<body>

		<div id="container"> </div>
		<div id="info">three.js PathTracing Renderer - BVH Debugging</div>
		
		<div id="cameraInfo" style="position:fixed; left:3%; bottom:2%; font-family:arial; font-type:bold; color:rgb(255,255,255);">
		FOV: 60 / Aperture: 0.00 / FocusDistance: 100 <br> 
		Samples: 0
		</div>

		<script src="js/three-r84.min.js"> </script>
		<script src="js/threex.keyboardstate.js"> </script>
		<script src="js/FirstPersonCameraControls.js"> </script>
		<script src="js/MobileJoystickControls.js"> </script>
		<script src="js/webgl-obj-loader.js"> </script>
		<script src="js/Detector.js"> </script>
		<script src="js/stats.min.js"> </script>
		
		
		<script id="screenTextureVertexShader" type="x-shader/x-vertex">
		
precision highp float;
precision highp int;

varying vec2 vUv;

void main()
{
	vUv = uv;
	gl_Position = vec4( position, 1.0 );

}

		</script>
		
		<script id="screenTextureFragmentShader" type="x-shader/x-fragment">

precision highp float;
precision highp int;
precision highp sampler2D;

varying vec2 vUv;
uniform sampler2D tTexture0;


void main()
{	
	gl_FragColor = texture2D(tTexture0, vUv);	
}
		
		</script>
		
		<script id="screenOutputVertexShader" type="x-shader/x-vertex">

precision highp float;
precision highp int;

varying vec2 vUv;

void main() 
{
	vUv = uv;
	gl_Position = vec4( position, 1.0 );
}

		</script>
		
		<script id="screenOutputFragmentShader" type="x-shader/x-fragment">

precision highp float;
precision highp int;
precision highp sampler2D;

varying vec2 vUv;
uniform float uOneOverSampleCounter;
uniform sampler2D tTexture0;

void main()
{
	vec4 pixelColor = texture2D(tTexture0, vUv) * uOneOverSampleCounter;
	
	gl_FragColor = sqrt(pixelColor);	
}
		
		</script>
		
		<script id="pathTracingVertexShader" type="x-shader/x-vertex">
		
precision highp float;
precision highp int;

varying vec2 vUv;

void main()
{
	vUv = uv;
	gl_Position = vec4( position, 1.0 );
}

		</script>
		
		
		
		<script id="pathTracingFragmentShader" type="x-shader/x-fragment">
				
precision highp float;
precision highp int;
precision highp sampler2D;

uniform bool uCameraIsMoving;
uniform bool uCameraJustStartedMoving;

uniform float uTime;
uniform float uSampleCounter;
uniform float uULen;
uniform float uVLen;
uniform float uApertureSize;
uniform float uFocusDistance;

uniform vec2 uResolution;

uniform vec3 uMeshBBox_min;
uniform vec3 uMeshBBox_max;
uniform vec3 uRandomVector;

uniform mat4 uCameraMatrix;
//uniform mat4 uSphereMeshesMatrix[4];

uniform sampler2D tPreviousTexture;
uniform sampler2D tTriangleTexture;
uniform sampler2D tAABBTexture;

varying vec2 vUv;

#define PI               3.14159265358979323
#define ONE_OVER_PI      0.31830988618379067
#define TWO_PI           6.28318530717958648
#define FOUR_PI          12.5663706143591729
#define ONE_OVER_FOUR_PI 0.07957747154594767
#define PI_OVER_TWO      1.57079632679489662
#define E                2.71828182845904524
#define INFINITY         1000000.0

#define SPHERE_ID 0
#define PLANE_ID 1
#define DISK_ID 2
#define TRIANGLE_ID 3
#define QUAD_ID 4
#define BOX_ID 5
#define ELLIPSOID_ID 6
#define CYLINDER_ID 7
#define CLOSEDCYLINDER_ID 8
#define CONE_ID 9
#define OBJ_TRIANGLE_ID 10

#define N_SPHERES 5
#define N_ELLIPSOIDS 1
#define N_PLANES 1
#define N_DISKS 1
#define N_TRIANGLES 1
#define N_QUADS 1
#define N_BOXES 2
#define N_CYLINDERS 1
#define N_CLOSEDCYLINDERS 1
#define N_CONES 1

#define LIGHT 0
#define DIFF 1
#define REFR 2
#define SPEC 3
#define CHECK 4
#define COAT 5
#define VOLUME 6
#define TRANSLUCENT 7
#define SPECSUB 8

vec3 debugSpherePos;
vec3 light0Pos;

float seed = 0.0;

float rand()
{ 
	return fract( sin( seed++ ) * 43758.5453123 );
}


//-----------------------------------------------------------------------

struct Ray { vec3 origin; vec3 direction; };
struct Sphere { float radius; vec3 position; vec3 emission; vec3 color; int type; };
/*
struct Ellipsoid { vec3 radii; vec3 position; vec3 emission; vec3 color; int type; };
struct Cylinder { float radius; float height; vec3 position; vec3 emission; vec3 color; int type; };
struct ClosedCylinder { float radius; vec3 cap1pos; vec3 cap2pos; vec3 emission; vec3 color; int type; };
struct Cone { float radius; float height; vec3 position; vec3 emission; vec3 color; int type; };
struct Plane { vec4 pla; vec3 emission; vec3 color; int type; };
struct Disk { float radiusSq; vec3 pos; vec3 normal; vec3 emission; vec3 color; int type; };
struct Triangle { vec3 normal; vec3 v0; vec3 v1; vec3 v2; vec3 emission; vec3 color; int type; };
struct Quad { vec3 normal; vec3 v0; vec3 v1; vec3 v2; vec3 v3; vec3 emission; vec3 color; int type; };
*/
struct Box { vec3 minCorner; vec3 maxCorner; vec3 emission; vec3 color; int type; };
struct Intersection { vec3 normal; vec3 emission; vec3 color; int type; int id; };

Sphere spheres[N_SPHERES];
/*
Ellipsoid ellipsoids[N_ELLIPSOIDS];
Cylinder cylinders[N_CYLINDERS];
ClosedCylinder closedCylinders[N_CLOSEDCYLINDERS];
Cone cones[N_CONES];
Plane planes[N_PLANES];
Disk disks[N_DISKS];
Triangle triangles[N_TRIANGLES];
Quad quads[N_QUADS];
*/
Box boxes[N_BOXES];



//-----------------------------------------------------------------------
float SphereIntersect( float rad, vec3 pos, Ray r )
//-----------------------------------------------------------------------
{
	vec3 op = pos - r.origin;
	float b = dot(op, r.direction);
	float det = b * b - dot(op,op) + rad * rad;
       	if (det < 0.0)
		return INFINITY;
        
	det = sqrt(det);	
	float t1 = b - det;
	if( t1 > 0.0 )
		return t1;
		
	float t2 = b + det;
	if( t2 > 0.0 )
		return t2;

	return INFINITY;	
}

//---------------------------------------------------------
float TriangleIntersect( vec3 v0, vec3 v1, vec3 v2, Ray r )
//---------------------------------------------------------
{
	vec3 edge1 = v1 - v0;
	vec3 edge2 = v2 - v0;
	vec3 tvec = r.origin - v0;
	vec3 pvec = cross(r.direction, edge2);
	float det = 1.0 / dot(edge1, pvec);
	float u = dot(tvec, pvec) * det;

	if (u < 0.0 || u > 1.0)
		return INFINITY;

	vec3 qvec = cross(tvec, edge1);

	float v = dot(r.direction, qvec) * det;

	if (v < 0.0 || u + v > 1.0)
		return INFINITY;

	return dot(edge2, qvec) * det;
}

//----------------------------------------------------------------------------
float BoxIntersect( vec3 minCorner, vec3 maxCorner, Ray r, out vec3 normal )
//----------------------------------------------------------------------------
{
	vec3 invDir = 1.0 / r.direction;
	vec3 tmin = (minCorner - r.origin) * invDir;
	vec3 tmax = (maxCorner - r.origin) * invDir;

	vec3 real_min = min(tmin, tmax);
   	vec3 real_max = max(tmin, tmax);
   
   	float minmax = min( min(real_max.x, real_max.y), real_max.z);
   	float maxmin = max( max(real_min.x, real_min.y), real_min.z);
	
	if (minmax < maxmin || minmax < 0.0) return INFINITY;
	
	if (maxmin > 0.0) // if we are outside the box
	{
		normal = -sign(r.direction) * step(real_min.yzx, real_min) * step(real_min.zxy, real_min);
		return maxmin;	
	}	
	else // else we are inside the box
	{
		normal = -sign(r.direction) * step(real_max, real_max.yzx) * step(real_max, real_max.zxy);
		return minmax;
	}	
}

//--------------------------------------------------------------------------------------
bool BoundingBoxIntersect( vec3 minCorner, vec3 maxCorner, vec3 rayOrigin, vec3 invDir )
//--------------------------------------------------------------------------------------
{
	vec3 tmin = (minCorner - rayOrigin) * invDir;
	vec3 tmax = (maxCorner - rayOrigin) * invDir;

	vec3 real_min = min(tmin, tmax);
   	vec3 real_max = max(tmin, tmax);
   
   	float minmax = min( min(real_max.x, real_max.y), real_max.z);
   	float maxmin = max( max(real_min.x, real_min.y), real_min.z);

	//return minmax > maxmin;
	return minmax > max(maxmin, 0.0);
}



float data[64];
float getData(int id)
{
    for (int i=0; i<32; i++)
    {
        if (i == id) return data[i];
    }
}

//-----------------------------------------------------------------------
float SceneIntersect( Ray r, inout Intersection intersec )
//-----------------------------------------------------------------------
{
	vec3 n;
	float d,f;
	float t = INFINITY;
	
        for (int i = 0; i < N_SPHERES; i++)
        {
		d = SphereIntersect( spheres[i].radius, spheres[i].position, r );
		if (d < t)
		{
			t = d;
			intersec.normal = (r.origin + r.direction * t) - spheres[i].position;
			intersec.emission = spheres[i].emission;
			intersec.color = spheres[i].color;
			intersec.type = spheres[i].type;
			intersec.id = SPHERE_ID;
		}
        }
	
	for (int i = 0; i < N_BOXES; i++)
        {
		d = BoxIntersect( boxes[i].minCorner, boxes[i].maxCorner, r, n );
		if (d < t)
		{
			t = d;
			intersec.normal = normalize(n);
			intersec.emission = boxes[i].emission;
			intersec.color = boxes[i].color;
			intersec.type = boxes[i].type;
			intersec.id = BOX_ID;
		}
        }
		
	// AABB BVH Intersection
	float bc, bd;
	float iX3;
	float InvTextureWidth = 0.00024414062; // (1.0 / 4096 texture width)
	vec3 aabbNodeData, aabbMin, aabbMax;
	vec3 inverseDir = 1.0 / r.direction;
	vec3 v0, v1, v2;
	float closer = 0.0;
	float farther = 0.0;
	float forkForLater = 0.0;
	float ni = 0.0;
	int stackptr = 1;
	float randFork = rand();
	
        // mimics 'while' loop with break condition
	for (int i = 0; i < 1; i += 0) // infinite loop
	{
		stackptr --;
		// check for break condition
		if (stackptr < 0)
		{
			if (forkForLater > 0.0)
			{
				ni = forkForLater;
				forkForLater = 0.0;
				//stackptr ++;
			}	
			else
				break;
		}
		
		iX3 = ni * 3.0;
		
		// (iX3 + 0.0) corresponds to .r:rightOffset, .g: nPrims,    .b: start
		// (iX3 + 1.0) corresponds to .x:aabbMin.x,   .y: aabbMin.y, .z: aabbMin.z
		// (iX3 + 2.0) corresponds to .x:aabbMax.x,   .y: aabbMax.y, .z: aabbMax.z
		aabbNodeData = texture2D( tAABBTexture, vec2((iX3 + 0.0) * InvTextureWidth, 0) ).rgb;
		
		if (aabbNodeData.r > 0.0) // Another Inner Node, Not a leaf
		{ 
			aabbMin      = texture2D( tAABBTexture, vec2((iX3 + 3.0 + 1.0) * InvTextureWidth, 0) ).rgb;     
			aabbMax      = texture2D( tAABBTexture, vec2((iX3 + 3.0 + 2.0) * InvTextureWidth, 0) ).rgb;
			bool hitc0 = BoundingBoxIntersect(aabbMin, aabbMax, r.origin, inverseDir);
			
			aabbMin      = texture2D( tAABBTexture, vec2((iX3 + (aabbNodeData.r * 3.0) + 1.0) * InvTextureWidth, 0) ).rgb;     
			aabbMax      = texture2D( tAABBTexture, vec2((iX3 + (aabbNodeData.r * 3.0) + 2.0) * InvTextureWidth, 0) ).rgb;
			bool hitc1 = BoundingBoxIntersect(aabbMin, aabbMax, r.origin, inverseDir);
			
			// Did we hit both nodes?
			if (hitc0 && hitc1)
			{
				if (rand() < 0.5)
				{
					closer = ni + 1.0;
					farther = ni + aabbNodeData.r;
				}
				else
				{
					farther = ni + 1.0;
					closer = ni + aabbNodeData.r;
				}
				
				ni = closer;
				stackptr ++;
				continue;
      			}
			/*
			// Did we hit both nodes?
			if (hitc0 && hitc1)
			{
				// assume the left child is a closer hit...
				closer = ni + 1.0;
				farther = ni + aabbNodeData.r;
				
				// only set this once
				if (forkForLater == 0.0)
				{
					forkForLater = farther;
				}
				
				ni = closer;
				stackptr ++;
				continue;
      			}
			*/
			else if (hitc0)
			{
				ni = ni + 1.0;
				stackptr ++;
				continue;
			}
			else if (hitc1)
			{
				ni = ni + aabbNodeData.r;
				stackptr ++;
				continue;
			}
    		} // end if (aabbNodeData.r > 0.0) // Another Inner Node, Not a leaf
		else // Is leaf -> Intersect all triangles in this leaf
		{
			for (float p = 0.0; p < float(NUMBER_OF_LEAF_PRIMITIVES); p += 1.0)
			{	
				v0 = texture2D( tTriangleTexture, vec2(((3.0 * aabbNodeData.b) + (p * 3.0) + 0.0) * InvTextureWidth, 0) ).rgb;	      
				v1 = texture2D( tTriangleTexture, vec2(((3.0 * aabbNodeData.b) + (p * 3.0) + 1.0) * InvTextureWidth, 0) ).rgb;	      
				v2 = texture2D( tTriangleTexture, vec2(((3.0 * aabbNodeData.b) + (p * 3.0) + 2.0) * InvTextureWidth, 0) ).rgb;

				d = TriangleIntersect( v0, v1, v2, r );

				if (d < t && d > 0.0)
				{
					t = d;
					intersec.normal = normalize( cross(v1-v0, v2-v0) );
					intersec.emission = vec3(0);
					intersec.color = vec3(1,1,1);
					intersec.type = DIFF;
					intersec.id = OBJ_TRIANGLE_ID;
				}
				
				if (p == aabbNodeData.g)
				{
					break;
				}
				
			} // end for (float p = 0.0; p < 4.0; p += 1.0)
			
		} // end else // Is leaf -> Intersect all triangles in this leaf
				
	} // end for (int i = 0; i < 1; i += 0) // infinite loop
	

	return t;
	
} // end float SceneIntersect( Ray r, inout Intersection intersec )

vec3 randomSphereDirection()
{
	vec2 r = vec2(rand(),rand())*TWO_PI;
	return vec3(sin(r.x)*vec2(sin(r.y),cos(r.y)),cos(r.x));	
}

vec3 randomCosWeightedDirectionInHemisphere(vec3 nl)
{
	float up = sqrt(rand()); // weighted cos(theta)
    	float over = sqrt(1.0 - up * up); // sin(theta)
    	float around = rand() * TWO_PI;
	vec3 u = normalize( cross( abs(nl.x) > 0.1 ? vec3(0, 1, 0) : vec3(1, 0, 0), nl ) );
	vec3 v = normalize( cross(nl, u) );
    	return vec3( cos(around) * over * u ) + ( sin(around) * over * v ) + (up * nl);		
}

//-----------------------------------------------------------------------
vec3 CalculateRadiance( Ray r )
//-----------------------------------------------------------------------
{
	vec3 accumCol = vec3(0.0);
        vec3 mask = vec3(1.0);
	vec3 checkCol0 = vec3(1);
	vec3 checkCol1 = vec3(0.5);
        Intersection intersec;
	bool bounceIsSpecular = true;
	int sampleDiffuseBudget = 2;
	
        for (int depth = 0; depth < 4; depth++)
	{
	
		float t = SceneIntersect(r, intersec);
		
		if (t == INFINITY)
		{
                        break;
		}
		
		
		// if we reached something bright, don't spawn any more rays
		if (intersec.type == LIGHT)
		{	

			//if (bounceIsSpecular)
			{
				accumCol += mask * intersec.emission;
			}
			
			break;
		}
		
		
		// useful data 
		vec3 n = intersec.normal;
                vec3 nl = dot(n,r.direction) <= 0.0 ? normalize(n) : normalize(n * -1.0);
		vec3 x = r.origin + r.direction * t;
		
		    
                if (intersec.type == DIFF || intersec.type == CHECK) // Ideal DIFFUSE reflection
                {
			if( intersec.type == CHECK )
			{
				float q = clamp( mod( dot( floor(x.xz * 0.04), vec2(1.0) ), 2.0 ) , 0.0, 1.0 );
				intersec.color = checkCol0 * q + checkCol1 * (1.0 - q);	
			}
			
			mask *= intersec.color;
			//accumCol += calcDirectLighting(mask, x, nl, spheres[0]);
                        
			// Russian Roulette
			if (rand() > 0.5)
				break;
			else mask *= 2.0;
			
			sampleDiffuseBudget -= 1;
			if (sampleDiffuseBudget < 0) break;
			
			// choose random Diffuse sample vector
			vec3 d = randomCosWeightedDirectionInHemisphere( nl );
			r = Ray( x, normalize(d) );
			r.origin += nl * 2.0;
			mask *= max(0.01, dot(r.direction, nl));
			bounceIsSpecular = false;
			continue;	
                }
		
                if (intersec.type == SPEC)  // Ideal SPECULAR reflection
                {
			r = Ray( x, reflect(r.direction, nl) );
			r.origin += nl * 2.0;
			mask *= intersec.color;
			bounceIsSpecular = true;
                        continue;
                }

                if (intersec.type == REFR)  // Ideal dielectric REFRACTION
		{
			bool into = dot(n,nl) > 0.0;  // Ray from outside going in?
			float nc = 1.0; // IOR of air
			float nt = 1.33; // IOR of water
			if ( !into ) 
			{
				nc = 1.33;
				nt = 1.0;
			}
			
			float nnt = nc / nt;
			vec3 tdir = refract(r.direction, nl, nnt);
				
			// Original Fresnel equations
			float cosThetaInc = dot(nl, r.direction);
			float cosThetaTra = dot(nl, tdir);
			float coefS = (nc * cosThetaInc - nt * cosThetaTra) / (nc * cosThetaInc + nt * cosThetaTra);
			float coefP = (nc * cosThetaTra - nt * cosThetaInc) / (nc * cosThetaTra + nt * cosThetaInc);
			float Re = ( (coefS * coefS) + (coefP * coefP) ) * 0.5; // Unpolarized
			//float Tr = 1.0 - Re;
		
			float transmissionProbability = rand();
			
			if( transmissionProbability > Re ) // transmit ray through surface
			{
				mask *= intersec.color;
				r = Ray(x, normalize(tdir));
				r.origin -= nl * 2.0;
				bounceIsSpecular = true;
				continue;
			}
			else // reflect ray from surface
			{
				r = Ray( x, reflect(r.direction, nl) );
			    	r.origin += nl * 2.0;
				bounceIsSpecular = true;
			    	continue;	
			}
		}
		
		if (intersec.type == COAT)  // Diffuse object underneath with ClearCoat on top (like car, or shiny pool ball)
		{
			
			// Schlick Fresnel approx.
			float ddn = dot(-r.direction, nl);
			float nc = 1.0; // IOR of air
			float nt = 1.4; // IOR of ClearCoat 
			float R0 = (nc - nt) / (nc + nt);
			R0 *= R0;
			float c = 1.0 - ddn;
			float Re = R0 + (1.0 - R0) * c * c * c * c * c;
			
			float shininess = 1.0;
			
			// choose random sample vector for diffuse material underneath ClearCoat
			vec3 d = randomCosWeightedDirectionInHemisphere( nl );
			
			// choose either specular reflection or diffuse
			if( rand() < Re )
			{	
				r = Ray( x, mix( normalize(d), reflect(r.direction, nl), shininess ) );
				r.origin += nl * 2.0;
				bounceIsSpecular = true;
				continue;	
			}
			else
			{
				r = Ray( x, normalize(d) );
				r.origin += nl * 2.0;
				mask *= intersec.color;
				
				//accumCol += calcDirectLighting(mask, x, nl, spheres[0]);
				//mask *= max(0.01, dot(r.direction, nl));
				bounceIsSpecular = false;
				continue;
			}
			
		} //end if (intersec.type == COAT)
		
		if (intersec.type == TRANSLUCENT)  // Translucent Sub-Surface Scattering material
		{
			float translucentDensity = 0.3;
			float scatteringDistance = -log(rand()) / translucentDensity;
			vec3 absorptionCoefficient = vec3(0.0, 0.18, 0.25) * 1.3;
			if (scatteringDistance > t) 
			{
				mask *= exp(-absorptionCoefficient * t); // transmission
				x = x + r.direction * scatteringDistance;
				r = Ray( x, r.direction );
				//bounceIsSpecular = false; // not set, in order to see lights through thin material
			}
			else
			{
				// Compute how much light was absorbed along the ray before it was scattered:
				mask *= exp(-absorptionCoefficient * scatteringDistance); // scattering
				x = x + r.direction * scatteringDistance;
				vec3 d = randomCosWeightedDirectionInHemisphere( nl );
				r = Ray( x, normalize(d) );
				bounceIsSpecular = false;	
			}
			
			//accumCol += calcDirectLighting(mask, x, nl, spheres[0]);
			
			continue;	
			
		} // end if (intersec.type == TRANSLUCENT)
		
		if (intersec.type == VOLUME)  // Volume filled with participating medium (i.e. smoke, fog, dust, etc.)
		{
                
			float density = 0.85;
			if (rand() < density)
			{
				// scattering
				// choose cosWeighted random Diffuse reflection vector for participating medium
				vec3 d = randomSphereDirection(); // true isotropic scattering
				r = Ray( x, normalize(d) );
				r.origin += nl * 2.0;
				mask *= intersec.color;
				
				//accumCol += calcDirectLighting(mask, x, nl, spheres[0]);
				mask *= max(0.01, dot(r.direction, nl));
				bounceIsSpecular = false;
				continue;
			}
			else
			{
				// transmission
				r = Ray( x, r.direction );
				r.origin += r.direction * 2.0;
				
				continue;
			}
				
		} // end if (intersec.type == VOLUME)
		
		if (intersec.type == SPECSUB)  // Shiny(specular) coating over Sub-Surface Scattering material
		{
			// Schlick Fresnel approx.
			float ddn = dot(-r.direction, nl);
			float nc = 1.0; // IOR of air
			float nt = 1.3; // IOR of coating (for polished jade)
			float R0 = (nc - nt) / (nc + nt);
			R0 *= R0;
			float c = 1.0 - ddn;
			float Re = R0 + (1.0 - R0) * c * c * c * c * c;
			
			// choose either specular reflection or translucent subsurface scattering/transmission
			if( bounceIsSpecular && rand() < Re )
			{
				r = Ray( x, reflect(r.direction, nl) );
				r.origin += nl * 2.0;
				bounceIsSpecular = true;
				continue;
			}
			
			vec3 absorptionCoefficient = vec3(0.4, 0.01, 0.07);
			float translucentDensity = 0.05;
			float scatteringDistance = -log(rand()) / translucentDensity;
			vec3 d;
			
			if (scatteringDistance < t) 
			{
				mask *= exp(-absorptionCoefficient * scatteringDistance); // scattering
				d = randomSphereDirection(); // true Isotropic scattering
				//d = randomCosWeightedDirectionInHemisphere( nl );
			}
			else
			{
				mask *= exp(-absorptionCoefficient * t); // transmission
				d = r.direction;
			}
			
			//accumCol += calcDirectLighting(mask, x, nl, spheres[0]);
			x = x + r.direction * scatteringDistance;
			r = Ray( x, normalize(d) );
			bounceIsSpecular = false;
			continue;			
		} // end if (intersec.type == SPECSUB)
		
		
	} // end for (int depth = 0; depth < 4; depth++)
	
	return accumCol;      
}


//-----------------------------------------------------------------------
void SetupScene(void)
//-----------------------------------------------------------------------
{
	vec3 z  = vec3(0);          
	vec3 L1 = vec3(1.0, 1.0, 1.0) * 3.0;// White light
	//vec3 L2 = vec3(1.0, 0.9, 0.6) * 3.0;// Yellowish light
	//vec3 L3 = vec3(0.2, 0.8, 1.0) * 3.0;// Blueish light
	
	spheres[0] = Sphere( 500.0, vec3(  0.0, 1000.0, 0.0), L1, z, LIGHT);//spherical white Light1
	spheres[1] = Sphere( 4000.0, vec3(0, -4000, 0), z, vec3(0.4,0.4,0.4), CHECK);//Checkered Floor
	spheres[2] = Sphere( 6.0,    vec3(55, 37, -45), z, vec3(0.7),          SPEC);//small mirror ball
	spheres[3] = Sphere( 6.0,    vec3(55, 25, -45), z, vec3(0.5,1.0,1.0),  REFR);//small glass ball
	spheres[4] = Sphere( 6.0,    vec3(60, 25, -30), z, vec3(1.0),          COAT);//small plastic ball
		
	boxes[0] = Box( vec3(-20.0,11.0,-110.0), vec3(70.0,18.0,-20.0), z, vec3(0.2,0.9,0.7), REFR);//Glass Box
	boxes[1] = Box( vec3(-14.0,13.0,-104.0), vec3(64.0,16.0,-26.0), z, vec3(0),           DIFF);//Inner Box
}



void main( void )
{

	vec3 camPos     = vec3( uCameraMatrix[3][0],  uCameraMatrix[3][1],  uCameraMatrix[3][2]);
	vec3 camRight   = vec3( uCameraMatrix[0][0],  uCameraMatrix[0][1],  uCameraMatrix[0][2]);
	vec3 camUp      = vec3( uCameraMatrix[1][0],  uCameraMatrix[1][1],  uCameraMatrix[1][2]);
	vec3 camForward = vec3(-uCameraMatrix[2][0], -uCameraMatrix[2][1], -uCameraMatrix[2][2]);
	
	// seed for rand() function
	seed = mod(uSampleCounter,1000.0) * uRandomVector.x - uRandomVector.y + uResolution.y * gl_FragCoord.x / uResolution.x + uResolution.x * gl_FragCoord.y / uResolution.y;
	
	float r1 = 2.0 * rand();
	float r2 = 2.0 * rand();
	
	vec2 d = vec2(0.0);
	if ( !uCameraIsMoving ) 
	{
		d.x = r1 < 1.0 ? sqrt(r1) - 1.0 : 1.0 - sqrt(2.0 - r1);
		d.y = r2 < 1.0 ? sqrt(r2) - 1.0 : 1.0 - sqrt(2.0 - r2);
	}
	
	d *= (1.0 / (uResolution * 0.5));
	d += 2.0 * vUv - 1.0;
	
	vec3 rayDir = normalize( d.x * camRight * uULen + d.y * camUp * uVLen + camForward );
	
	// depth of field
	vec3 focalPoint = uFocusDistance * rayDir;
	float randomAngle = rand() * TWO_PI; // pick random point on aperture
	float randomRadius = rand() * uApertureSize;
	vec3  randomAperturePos = ( cos(randomAngle) * camRight + sin(randomAngle) * camUp ) * randomRadius;
	// point on aperture to focal point
	vec3 finalRayDir = normalize(focalPoint - randomAperturePos);
	
	Ray ray = Ray( camPos + randomAperturePos , finalRayDir );
	
	SetupScene();
	
	// perform path tracing and get resulting pixel color
	vec3 pixelColor = CalculateRadiance( ray );
	
	vec3 previousColor = texture2D(tPreviousTexture, vUv).rgb;
	
	if ( uCameraJustStartedMoving )
	{
		previousColor = vec3(0.0); // clear rendering accumulation buffer
		pixelColor *= 1.5; //2.0
	}
	else if ( uCameraIsMoving )
	{
		previousColor *= 0.5; // motion-blur trail amount (old image)
		pixelColor *= (uSampleCounter) * 0.5; // brightness of new image (noisy)
		
	}
		
	gl_FragColor = vec4( pixelColor + previousColor, 1.0 );
	
}

		</script>
		
		
		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var SCREEN_WIDTH = window.innerWidth;
			var SCREEN_HEIGHT = window.innerHeight;
			var container, stats;
			var controls;
			var pathTracingScene, screenTextureScene, screenOutputScene;
			var pathTracingUniforms, screenTextureUniforms, screenOutputUniforms;
			var pathTracingDefines;
			var pathTracingGeometry, pathTracingMaterial, pathTracingMesh;
			var screenTextureGeometry, screenTextureMaterial, screenTextureMesh;
			var screenOutputGeometry, screenOutputMaterial, screenOutputMesh;
			var pathTracingRenderTarget, screenOutputRenderTarget;
			var quadCamera, worldCamera;
			var renderer, clock;
			var frameTime, elapsedTime;
			var fovScale;
			var increaseFOV = false;
			var decreaseFOV = false;
			var apertureSize = 0.0;
			var increaseAperture = false;
			var decreaseAperture = false;
			var focusDistance = 100.0;
			var increaseFocusDist = false;
			var decreaseFocusDist = false;
			var pixelRatio = window.devicePixelRatio * 0.5;
			var TWO_PI = Math.PI * 2;
			var randomVector = new THREE.Vector3();
			var sampleCounter = 1.0;
			var keyboard = new THREEx.KeyboardState();
			var cameraIsMoving = false;
			var cameraJustStartedMoving = false;
			var cameraRecentlyMoving = false;
			var isPaused = true;
			var oldYawRotation, oldPitchRotation;
			var mobileJoystickControls = null;
			var oldDeltaX = 0, oldDeltaY = 0;
			var newDeltaX = 0, newDeltaY = 0;
			var mobileControlsMoveX = 0;
			var mobileControlsMoveY = 0;
			var stillFlagX = true, stillFlagY = true;
			var oldPinchWidthX = 0;
			var oldPinchWidthY = 0;
			var pinchDeltaX = 0;
			var pinchDeltaY = 0;
			var camFlightSpeed = 60;
			var fontAspect;
			var objMeshes = {};
			var total_number_of_triangles = 0;
			var triangle_array;
			var triangleDataTexture;
			var aabb_array;
			var aabbDataTexture;
			var v0 = new THREE.Vector3();
			var v1 = new THREE.Vector3();
			var v2 = new THREE.Vector3();
			var scene_aabbox_min = new THREE.Vector3();
			var scene_aabbox_max = new THREE.Vector3();
			
			// the following variables will be used to calculate rotations and directions from the camera
			var cameraDirectionVector = new THREE.Vector3();//for moving where the camera is looking
			var cameraRightVector = new THREE.Vector3();//for strafing the camera right and left
			var cameraUpVector = new THREE.Vector3();//for moving camera up and down
			var cameraWorldQuaternion = new THREE.Quaternion();//for rotating scene objects to match camera's current rotation
			var cameraControlsObject;//for positioning and moving the camera itself
			var cameraControlsYawObject;//allows access to control camera's left/right movements through mobile input
			var cameraControlsPitchObject;//allows access to control camera's up/down movements through mobile input

			var PI_2 = Math.PI / 2;//used by controls below
			
			var infoElement = document.getElementById( 'info' );
			infoElement.style.cursor = "default";
			infoElement.style.webkitUserSelect = "none";
			infoElement.style.MozUserSelect = "none";
			
			var cameraInfoElement = document.getElementById( 'cameraInfo' );
			cameraInfoElement.style.cursor = "default";
			cameraInfoElement.style.webkitUserSelect = "none";
			cameraInfoElement.style.MozUserSelect = "none";
			
			var mouseControl = true;

			if ( 'createTouch' in document ) {
				mouseControl = false;
				pixelRatio = window.devicePixelRatio * 0.18;
				
				mobileJoystickControls = new MobileJoystickControls ({
					//showJoystick: true,
					enableMultiTouch: true
				});	
			}

			// if on mobile device, unpause the app because there is no ESC key and no mouse capture to do
			if ( !mouseControl )
				isPaused = false;
			
			if (mouseControl) {

				window.addEventListener( 'wheel', onMouseWheel, false );
				
				document.body.addEventListener("click", function() {
					this.requestPointerLock = this.requestPointerLock || this.mozRequestPointerLock;
					this.requestPointerLock();
				}, false);

				window.addEventListener("click", function(event) {
					event.preventDefault();	
				}, false);
				window.addEventListener("dblclick", function(event) {
					event.preventDefault();	
				}, false);


				var pointerlockChange = function ( event ) {

					if ( document.pointerLockElement === document.body || 
					    document.mozPointerLockElement === document.body || document.webkitPointerLockElement === document.body ) {

						isPaused = false;

					} else {

						isPaused = true;

					}

				};

				// Hook pointer lock state change events
				document.addEventListener( 'pointerlockchange', pointerlockChange, false );
				document.addEventListener( 'mozpointerlockchange', pointerlockChange, false );
				document.addEventListener( 'webkitpointerlockchange', pointerlockChange, false );

			}
			
			function onMouseWheel( event ) {

				event.preventDefault();
				event.stopPropagation();

				if ( event.deltaY > 0 ) {
					
					increaseFOV = true;
				
				} else if ( event.deltaY < 0 ) {
					
					decreaseFOV = true;
					
				}

			}

			OBJ.downloadMeshes( {
    				//'my_mesh': 'models/name.obj', // located in the models folder on the server
    				
				//'my_mesh': 'models/diamond.obj' // 8 tris
				//'my_mesh': 'models/cube.obj' // 12 tris
				//'my_mesh': 'models/crane.obj' // 36 tris
				//'my_mesh': 'models/emerald.obj' // 140 tris
				'my_mesh': 'models/desktopPC.obj' // 215 tris
				//'my_mesh': 'models/volkswagenLogo.obj' // 284 tris
				//'my_mesh': 'models/tree.obj' // 500 tris
				//'my_mesh': 'models/shuttle.obj' // 616 tris
				//'my_mesh': 'models/monkey.obj' // 968 tris
				//'my_mesh': 'models/teapot.obj' // 1024 tris
				//'my_mesh': 'models/bunny.obj'
				
  			}, init );
			
			
/* BVH (Bounding Volume Hierarchy) Builder */
/*
Original author: Brandon Pelfrey (brandonpelfrey@gmail.com) (brandonpelfrey on GitHub)
https://github.com/brandonpelfrey/Fast-BVH

Edited and Ported from C++ to Javascript by: Erich Loftis (erichlof on GitHub)
https://github.com/erichlof/THREE.js-PathTracing-Renderer
*/
var nNodes = 0;
var nLeafs = 0;
var leafSize = 4;
var flatTree = [];

function BBox(_min, _max) {
	
	this.minCorner = new THREE.Vector3(Infinity,Infinity,Infinity);
	if (_min) this.minCorner.copy(_min);
	this.maxCorner = new THREE.Vector3(-Infinity,-Infinity,-Infinity);
	if (_max) this.maxCorner.copy(_max);
	
	this.extentVec = new THREE.Vector3();

	this.expandToIncludePoint = function(p) {
		this.minCorner.min(p);
		this.maxCorner.max(p);
		this.extentVec.subVectors(this.maxCorner, this.minCorner);
	};

	this.expandToIncludeBox = function(b) {
		this.minCorner.min(b.minCorner);
		this.maxCorner.max(b.maxCorner);
		this.extentVec.subVectors(this.maxCorner, this.minCorner);
	};

	this.maxDimension = function() {
		var result = 0;
		if (this.extentVec.y > this.extentVec.x) {
			result = 1;
			if (this.extentVec.z > this.extentVec.y) 
				result = 2;
		} 
		else if (this.extentVec.z > this.extentVec.x) result = 2;

		return result;
	}

	this.surfaceArea = function() {
		return 2 * ( this.extentVec.x * this.extentVec.z +
			     this.extentVec.x * this.extentVec.y + 
			     this.extentVec.y * this.extentVec.z );
	}

} // end function BBox(_min, _max) {

function BVH_BuildEntry() {
	// If non-zero then this is the index of the parent. (used in offsets)
	this.parent = 0;
	// The range of objects in the object list covered by this node.
	this.start = 0;
	this.end = 0;
}

function BVH_FlatNode() {
	this.rightOffset = 0;
	this.nPrims = 0;
	this.start = 0;
	this.bbox = new BBox();
}

/*! Build the BVH, given an input data set
 *  - Handling our own stack is quite a bit faster than the recursive style.
 *  - Each build stack entry's parent field eventually stores the offset
 *    to the parent of that node. Before that is finally computed, it will
 *    equal exactly three other values. (These are the magic values Untouched,
 *    Untouched-1, and TouchedTwice).
 *  - The partition here was also slightly faster than std::partition.
 */	
function BVH_Build() {
	
	var todo = [];
	var buildnodes = [];
	var stackptr = 0;
	var Untouched = 0xffffffff;
	var TouchedTwice = 0xfffffffd;
	
	var testBox = new BBox();
	var testPoint = new THREE.Vector3();
	var tempMin = new THREE.Vector3();
	var tempMax = new THREE.Vector3();
	var tempCen = new THREE.Vector3();
	var tempV1 = new THREE.Vector3();
	var tempV2 = new THREE.Vector3();
	var tempV3 = new THREE.Vector3();

	for (var i = 0; i < 128; i++) {
		todo[i] = new BVH_BuildEntry();
	}
	// Push the root
	todo[stackptr].start = 0;
	todo[stackptr].end = total_number_of_triangles;
	todo[stackptr].parent = 0xfffffffc;
	stackptr++;

	while (stackptr > 0) {
		
		nNodes++;
		
		// Pop the next item off of the stack
		stackptr--;
		var split_dim = 0;	
		var split_coord = 0;
		var bnode = todo[stackptr];
		var start = bnode.start;
		var mid = 0;
		var end = bnode.end;
		var nPrims = end - start;
		
		var node = new BVH_FlatNode();
		node.start = start;
		node.nPrims = nPrims;
		node.rightOffset = Untouched;
		
		// Calculate the bounding box for this node
		var bb = new BBox();
		var bc = new BBox();
		
		bb.minCorner.set( aabb_array[9*start+0], aabb_array[9*start+1], aabb_array[9*start+2] );
		bb.maxCorner.set( aabb_array[9*start+3], aabb_array[9*start+4], aabb_array[9*start+5] );
		bc.minCorner.set( aabb_array[9*start+6], aabb_array[9*start+7], aabb_array[9*start+8] );
		//bc.maxCorner.set(-Infinity,-Infinity,-Infinity);
		for (var p = start + 1; p < end; ++p) {
			testBox.minCorner.set( aabb_array[9*p+0], aabb_array[9*p+1], aabb_array[9*p+2] );
			testBox.maxCorner.set( aabb_array[9*p+3], aabb_array[9*p+4], aabb_array[9*p+5] );
			bb.expandToIncludeBox(testBox);
			testPoint.set( aabb_array[9*p+6], aabb_array[9*p+7], aabb_array[9*p+8] );
			bc.expandToIncludePoint(testPoint);
		}
		node.bbox = bb;

		// If the number of primitives at this point is less than the leaf
		// size, then this will become a leaf. (Signified by rightOffset == 0)
		if (nPrims <= leafSize) {
			node.rightOffset = 0;
			nLeafs++;
		}

		buildnodes.push(node);

		// Child touches parent...
		// Special case: Don't do this for the root (root is 0xfffffffc).
		if (bnode.parent != 0xfffffffc) {
			buildnodes[bnode.parent].rightOffset--;

			// When this is the second touch, this is the right child.
			// The right child sets up the offset for the flat tree.
			if (buildnodes[bnode.parent].rightOffset == TouchedTwice) {
				buildnodes[bnode.parent].rightOffset = nNodes - 1 - bnode.parent;
			}
		}

		// If this is a leaf, no need to subdivide.
		if (node.rightOffset == 0)
			continue;

		// Set the split dimensions
		split_dim = bc.maxDimension();
			
		// Split on the center of the longest axis, then
		// Partition the list of objects on this split
		mid = start;
		if (split_dim == 0) {
			// Split on the center of the X axis
			split_coord = 0.5 * (bc.minCorner.x + bc.maxCorner.x);
								
			for (var i = start; i < end; ++i) {
				if (aabb_array[9*i+6] < split_coord) {
					//swap [i] and [mid] bbox data
					tempMin.set( aabb_array[9*i+0], aabb_array[9*i+1], aabb_array[9*i+2] );
					tempMax.set( aabb_array[9*i+3], aabb_array[9*i+4], aabb_array[9*i+5] ); 
					tempCen.set( aabb_array[9*i+6], aabb_array[9*i+7], aabb_array[9*i+8] ); 
					
					aabb_array[9*i+0] = aabb_array[9*mid+0]; aabb_array[9*i+1] = aabb_array[9*mid+1]; aabb_array[9*i+2] = aabb_array[9*mid+2];
					aabb_array[9*i+3] = aabb_array[9*mid+3]; aabb_array[9*i+4] = aabb_array[9*mid+4]; aabb_array[9*i+5] = aabb_array[9*mid+5];
					aabb_array[9*i+6] = aabb_array[9*mid+6]; aabb_array[9*i+7] = aabb_array[9*mid+7]; aabb_array[9*i+8] = aabb_array[9*mid+8];
					
					aabb_array[9*mid+0] = tempMin.x; aabb_array[9*mid+1] = tempMin.y; aabb_array[9*mid+2] = tempMin.z;
					aabb_array[9*mid+3] = tempMax.x; aabb_array[9*mid+4] = tempMax.y; aabb_array[9*mid+5] = tempMax.z;
					aabb_array[9*mid+6] = tempCen.x; aabb_array[9*mid+7] = tempCen.y; aabb_array[9*mid+8] = tempCen.z;
					
					//swap [i] and [mid] triangle data
					tempV1.set( triangle_array[9*i+0], triangle_array[9*i+1], triangle_array[9*i+2] );
					tempV2.set( triangle_array[9*i+3], triangle_array[9*i+4], triangle_array[9*i+5] ); 
					tempV3.set( triangle_array[9*i+6], triangle_array[9*i+7], triangle_array[9*i+8] ); 
					
					triangle_array[9*i+0] = triangle_array[9*mid+0]; triangle_array[9*i+1] = triangle_array[9*mid+1]; triangle_array[9*i+2] = triangle_array[9*mid+2];
					triangle_array[9*i+3] = triangle_array[9*mid+3]; triangle_array[9*i+4] = triangle_array[9*mid+4]; triangle_array[9*i+5] = triangle_array[9*mid+5];
					triangle_array[9*i+6] = triangle_array[9*mid+6]; triangle_array[9*i+7] = triangle_array[9*mid+7]; triangle_array[9*i+8] = triangle_array[9*mid+8];
					
					triangle_array[9*mid+0] = tempV1.x; triangle_array[9*mid+1] = tempV1.y; triangle_array[9*mid+2] = tempV1.z;
					triangle_array[9*mid+3] = tempV2.x; triangle_array[9*mid+4] = tempV2.y; triangle_array[9*mid+5] = tempV2.z;
					triangle_array[9*mid+6] = tempV3.x; triangle_array[9*mid+7] = tempV3.y; triangle_array[9*mid+8] = tempV3.z;
					
					++mid;
				}
			}
		} // end if (split_dim == 0) {
		else if (split_dim == 1) {
			// Split on the center of the Y axis
			split_coord = 0.5 * (bc.minCorner.y + bc.maxCorner.y);
			
			for (var i = start; i < end; ++i) {
				if (aabb_array[9*i+7] < split_coord) {
					//swap [i] and [mid] bbox data
					tempMin.set( aabb_array[9*i+0], aabb_array[9*i+1], aabb_array[9*i+2] );
					tempMax.set( aabb_array[9*i+3], aabb_array[9*i+4], aabb_array[9*i+5] ); 
					tempCen.set( aabb_array[9*i+6], aabb_array[9*i+7], aabb_array[9*i+8] ); 
					
					aabb_array[9*i+0] = aabb_array[9*mid+0]; aabb_array[9*i+1] = aabb_array[9*mid+1]; aabb_array[9*i+2] = aabb_array[9*mid+2];
					aabb_array[9*i+3] = aabb_array[9*mid+3]; aabb_array[9*i+4] = aabb_array[9*mid+4]; aabb_array[9*i+5] = aabb_array[9*mid+5];
					aabb_array[9*i+6] = aabb_array[9*mid+6]; aabb_array[9*i+7] = aabb_array[9*mid+7]; aabb_array[9*i+8] = aabb_array[9*mid+8];
					
					aabb_array[9*mid+0] = tempMin.x; aabb_array[9*mid+1] = tempMin.y; aabb_array[9*mid+2] = tempMin.z;
					aabb_array[9*mid+3] = tempMax.x; aabb_array[9*mid+4] = tempMax.y; aabb_array[9*mid+5] = tempMax.z;
					aabb_array[9*mid+6] = tempCen.x; aabb_array[9*mid+7] = tempCen.y; aabb_array[9*mid+8] = tempCen.z;
					
					//swap [i] and [mid] triangle data
					tempV1.set( triangle_array[9*i+0], triangle_array[9*i+1], triangle_array[9*i+2] );
					tempV2.set( triangle_array[9*i+3], triangle_array[9*i+4], triangle_array[9*i+5] ); 
					tempV3.set( triangle_array[9*i+6], triangle_array[9*i+7], triangle_array[9*i+8] ); 
					
					triangle_array[9*i+0] = triangle_array[9*mid+0]; triangle_array[9*i+1] = triangle_array[9*mid+1]; triangle_array[9*i+2] = triangle_array[9*mid+2];
					triangle_array[9*i+3] = triangle_array[9*mid+3]; triangle_array[9*i+4] = triangle_array[9*mid+4]; triangle_array[9*i+5] = triangle_array[9*mid+5];
					triangle_array[9*i+6] = triangle_array[9*mid+6]; triangle_array[9*i+7] = triangle_array[9*mid+7]; triangle_array[9*i+8] = triangle_array[9*mid+8];
					
					triangle_array[9*mid+0] = tempV1.x; triangle_array[9*mid+1] = tempV1.y; triangle_array[9*mid+2] = tempV1.z;
					triangle_array[9*mid+3] = tempV2.x; triangle_array[9*mid+4] = tempV2.y; triangle_array[9*mid+5] = tempV2.z;
					triangle_array[9*mid+6] = tempV3.x; triangle_array[9*mid+7] = tempV3.y; triangle_array[9*mid+8] = tempV3.z;
					
					++mid;
				}
			}
		} // end else if (split_dim == 1) {
		else if (split_dim == 2) {
			// Split on the center of the Z axis
			split_coord = 0.5 * (bc.minCorner.z + bc.maxCorner.z);
			
			for (var i = start; i < end; ++i) {
				if (aabb_array[9*i+8] < split_coord) {
					//swap [i] and [mid] bbox data
					tempMin.set( aabb_array[9*i+0], aabb_array[9*i+1], aabb_array[9*i+2] );
					tempMax.set( aabb_array[9*i+3], aabb_array[9*i+4], aabb_array[9*i+5] ); 
					tempCen.set( aabb_array[9*i+6], aabb_array[9*i+7], aabb_array[9*i+8] ); 
					
					aabb_array[9*i+0] = aabb_array[9*mid+0]; aabb_array[9*i+1] = aabb_array[9*mid+1]; aabb_array[9*i+2] = aabb_array[9*mid+2];
					aabb_array[9*i+3] = aabb_array[9*mid+3]; aabb_array[9*i+4] = aabb_array[9*mid+4]; aabb_array[9*i+5] = aabb_array[9*mid+5];
					aabb_array[9*i+6] = aabb_array[9*mid+6]; aabb_array[9*i+7] = aabb_array[9*mid+7]; aabb_array[9*i+8] = aabb_array[9*mid+8];
					
					aabb_array[9*mid+0] = tempMin.x; aabb_array[9*mid+1] = tempMin.y; aabb_array[9*mid+2] = tempMin.z;
					aabb_array[9*mid+3] = tempMax.x; aabb_array[9*mid+4] = tempMax.y; aabb_array[9*mid+5] = tempMax.z;
					aabb_array[9*mid+6] = tempCen.x; aabb_array[9*mid+7] = tempCen.y; aabb_array[9*mid+8] = tempCen.z;
					
					//swap [i] and [mid] triangle data
					tempV1.set( triangle_array[9*i+0], triangle_array[9*i+1], triangle_array[9*i+2] );
					tempV2.set( triangle_array[9*i+3], triangle_array[9*i+4], triangle_array[9*i+5] ); 
					tempV3.set( triangle_array[9*i+6], triangle_array[9*i+7], triangle_array[9*i+8] ); 
					
					triangle_array[9*i+0] = triangle_array[9*mid+0]; triangle_array[9*i+1] = triangle_array[9*mid+1]; triangle_array[9*i+2] = triangle_array[9*mid+2];
					triangle_array[9*i+3] = triangle_array[9*mid+3]; triangle_array[9*i+4] = triangle_array[9*mid+4]; triangle_array[9*i+5] = triangle_array[9*mid+5];
					triangle_array[9*i+6] = triangle_array[9*mid+6]; triangle_array[9*i+7] = triangle_array[9*mid+7]; triangle_array[9*i+8] = triangle_array[9*mid+8];
					
					triangle_array[9*mid+0] = tempV1.x; triangle_array[9*mid+1] = tempV1.y; triangle_array[9*mid+2] = tempV1.z;
					triangle_array[9*mid+3] = tempV2.x; triangle_array[9*mid+4] = tempV2.y; triangle_array[9*mid+5] = tempV2.z;
					triangle_array[9*mid+6] = tempV3.x; triangle_array[9*mid+7] = tempV3.y; triangle_array[9*mid+8] = tempV3.z;
					
					++mid;
				}
			}
		} // end else if (split_dim == 2) {
		
		// If we get a bad split, just choose the center...
		if (mid == start || mid == end) {
			mid = start + (end - start) * 0.5;
		}

		// Push right child
		todo[stackptr].start = mid;
		todo[stackptr].end = end;
		todo[stackptr].parent = nNodes - 1;
		stackptr++;

		// Push left child
		todo[stackptr].start = start;
		todo[stackptr].end = mid;
		todo[stackptr].parent = nNodes - 1;
		stackptr++;
		
	} // end while (stackptr > 0) {

	// Copy the temp node data to the flat array
	for (var n = 0; n < nNodes; ++n) {
		flatTree[n] = buildnodes[n];	
	}
	
	// Copy the flat array to the aabb_array
	for (var n = 0; n < nNodes; ++n) {
		
		aabb_array[9 * n + 0] = flatTree[n].rightOffset;
		aabb_array[9 * n + 1] = flatTree[n].nPrims;
		aabb_array[9 * n + 2] = flatTree[n].start;
		
		aabb_array[9 * n + 3] = flatTree[n].bbox.minCorner.x;
		aabb_array[9 * n + 4] = flatTree[n].bbox.minCorner.y;
		aabb_array[9 * n + 5] = flatTree[n].bbox.minCorner.z;
		
		aabb_array[9 * n + 6] = flatTree[n].bbox.maxCorner.x;
		aabb_array[9 * n + 7] = flatTree[n].bbox.maxCorner.y;
		aabb_array[9 * n + 8] = flatTree[n].bbox.maxCorner.z;
		
	}

} // end function BVH_Build() {	
					
  							
			function init( meshes ) {

				renderer = new THREE.WebGLRenderer();
				renderer.autoClear = false;
				// 1 is full resolution, 0.5 is half, 0.25 is quarter, etc. (must be > than 0.0)
				renderer.setPixelRatio(pixelRatio);
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.context.getExtension('OES_texture_float');
				
				container = document.getElementById( 'container' );
				container.appendChild( renderer.domElement );
		      
				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				stats.domElement.style.cursor = "default";
				stats.domElement.style.webkitUserSelect = "none";
				stats.domElement.style.MozUserSelect = "none";
				container.appendChild( stats.domElement );
				
				window.addEventListener( 'resize', onWindowResize, false );
				
				clock = new THREE.Clock();
				
				pathTracingScene = new THREE.Scene();
				screenTextureScene = new THREE.Scene();
				screenOutputScene = new THREE.Scene();
				
				// quadCamera is simply the camera to help render the full screen quad (2 triangles),
				// hence the name.  It is an Orthographic camera that sits facing the view plane, which serves as
				// the window into our 3d world. This camera will not move or rotate for the duration of the app.
				quadCamera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );
				screenTextureScene.add(quadCamera);
				screenOutputScene.add(quadCamera);
				
				// worldCamera is the dynamic camera 3d object that will be positioned, oriented and 
				// constantly updated inside the 3d scene.  Its view will ultimately get passed back to the 
				// stationary quadCamera, which renders the scene to a fullscreen quad (made up of 2 large triangles).
				worldCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
				pathTracingScene.add(worldCamera);
				
				controls = new FirstPersonCameraControls( worldCamera );
							
				cameraControlsObject = controls.getObject();
				cameraControlsYawObject = controls.getYawObject();
				cameraControlsPitchObject = controls.getPitchObject();
				
				pathTracingScene.add( cameraControlsObject );

				// for flyCam
				cameraControlsObject.position.set(0,40,95);
				
				// look slightly downward
				cameraControlsPitchObject.rotation.x = -0.2;
				
				oldYawRotation = cameraControlsYawObject.rotation.y;
				oldPitchRotation = cameraControlsPitchObject.rotation.x;
				
				// now that we moved and rotated the camera, the following line force-updates the camera's matrix,
				//  and prevents rendering the very first frame in the old default camera position/orientation
				cameraControlsObject.updateMatrixWorld(true);
				
				pathTracingRenderTarget = new THREE.WebGLRenderTarget( (window.innerWidth * pixelRatio), (window.innerHeight * pixelRatio), {
					minFilter: THREE.NearestFilter,
					magFilter: THREE.NearestFilter,
					format: THREE.RGBAFormat,
					type: THREE.FloatType,
					depthBuffer: false,
					stencilBuffer: false
				} );
				pathTracingRenderTarget.texture.generateMipmaps = false;
				
				screenTextureRenderTarget = new THREE.WebGLRenderTarget( (window.innerWidth * pixelRatio), (window.innerHeight * pixelRatio), {
					minFilter: THREE.NearestFilter, 
					magFilter: THREE.NearestFilter,
					format: THREE.RGBAFormat,
					type: THREE.FloatType,
					depthBuffer: false,
					stencilBuffer: false
				} );
				screenTextureRenderTarget.texture.generateMipmaps = false;
			
				objMeshes = meshes;
				//console.log(objMeshes.my_mesh.uniqueVertexList);
  				//console.log(objMeshes.my_mesh.faceIndices);

				total_number_of_triangles = objMeshes.my_mesh.faceIndices.length / 3;
				console.log("Triangle count:" + total_number_of_triangles);
				
				var buffer1 = new ArrayBuffer(4096 * 3 * 4); 
				//4096 = max width of texture, 3 = r,g, and b components, 4 = bytes each (4bytes*8bits=32bit for Float32Array)
				triangle_array = new Float32Array( buffer1 );
				
				var buffer2 = new ArrayBuffer(4096 * 3 * 4); 
				//4096 = max width of texture, 3 = r,g, and b components, 4 = bytes each (4bytes*8bits=32bit for Float32Array)
				aabb_array = new Float32Array( buffer2 );
				
				var modelScale = 1.0;
				var modelPositionOffset = new THREE.Vector3(0,18,-50);
				
				var b_box_min = new THREE.Vector3(Infinity, Infinity, Infinity);
        			var b_box_max = new THREE.Vector3(-Infinity, -Infinity, -Infinity);
				var triangle_b_box_min = new THREE.Vector3();
        			var triangle_b_box_max = new THREE.Vector3();
				var triangle_b_box_centroid = new THREE.Vector3();
				
				for (var i = 0, j = 0; i < objMeshes.my_mesh.faceIndices.length; i+=3, j++) {
					
					triangle_b_box_min.set(Infinity, Infinity, Infinity);
        				triangle_b_box_max.set(-Infinity, -Infinity, -Infinity);
					
					v0.set( objMeshes.my_mesh.uniqueVertexList[ 3 * objMeshes.my_mesh.faceIndices[i+0] + 0 ],
					        objMeshes.my_mesh.uniqueVertexList[ 3 * objMeshes.my_mesh.faceIndices[i+0] + 1 ],
					        objMeshes.my_mesh.uniqueVertexList[ 3 * objMeshes.my_mesh.faceIndices[i+0] + 2 ]
					      );
					v1.set( objMeshes.my_mesh.uniqueVertexList[ 3 * objMeshes.my_mesh.faceIndices[i+1] + 0 ],
					        objMeshes.my_mesh.uniqueVertexList[ 3 * objMeshes.my_mesh.faceIndices[i+1] + 1 ],
				                objMeshes.my_mesh.uniqueVertexList[ 3 * objMeshes.my_mesh.faceIndices[i+1] + 2 ] 
					      );
					v2.set( objMeshes.my_mesh.uniqueVertexList[ 3 * objMeshes.my_mesh.faceIndices[i+2] + 0 ],
					        objMeshes.my_mesh.uniqueVertexList[ 3 * objMeshes.my_mesh.faceIndices[i+2] + 1 ],
					        objMeshes.my_mesh.uniqueVertexList[ 3 * objMeshes.my_mesh.faceIndices[i+2] + 2 ] 
				              );
					
					b_box_min.copy( b_box_min.min(v0) );
	        			b_box_max.copy( b_box_max.max(v0) );
					b_box_min.copy( b_box_min.min(v1) );
	        			b_box_max.copy( b_box_max.max(v1) );
					b_box_min.copy( b_box_min.min(v2) );
	        			b_box_max.copy( b_box_max.max(v2) );
							
					v0.multiplyScalar( modelScale );
					v1.multiplyScalar( modelScale );
					v2.multiplyScalar( modelScale );
						
					v0.add( modelPositionOffset );
					v1.add( modelPositionOffset );
					v2.add( modelPositionOffset );
					
					triangle_array[9*j+0] = v0.x; triangle_array[9*j+1] = v0.y; triangle_array[9*j+2] = v0.z;     
					triangle_array[9*j+3] = v1.x; triangle_array[9*j+4] = v1.y; triangle_array[9*j+5] = v1.z;
					triangle_array[9*j+6] = v2.x; triangle_array[9*j+7] = v2.y; triangle_array[9*j+8] = v2.z;
					
					triangle_b_box_min.copy( triangle_b_box_min.min(v0) );
	        			triangle_b_box_max.copy( triangle_b_box_max.max(v0) );
					triangle_b_box_min.copy( triangle_b_box_min.min(v1) );
	        			triangle_b_box_max.copy( triangle_b_box_max.max(v1) );
					triangle_b_box_min.copy( triangle_b_box_min.min(v2) );
	        			triangle_b_box_max.copy( triangle_b_box_max.max(v2) );
					
					triangle_b_box_centroid.set( (triangle_b_box_min.x + triangle_b_box_max.x) * 0.5,
								     (triangle_b_box_min.y + triangle_b_box_max.y) * 0.5,
								     (triangle_b_box_min.z + triangle_b_box_max.z) * 0.5 );
					
					aabb_array[9*j+0] = triangle_b_box_min.x;      aabb_array[9*j+1] = triangle_b_box_min.y;      aabb_array[9*j+2] = triangle_b_box_min.z;     
					aabb_array[9*j+3] = triangle_b_box_max.x;      aabb_array[9*j+4] = triangle_b_box_max.y;      aabb_array[9*j+5] = triangle_b_box_max.z;
					aabb_array[9*j+6] = triangle_b_box_centroid.x; aabb_array[9*j+7] = triangle_b_box_centroid.y; aabb_array[9*j+8] = triangle_b_box_centroid.z;
						
				}
				
				objMeshes.my_mesh.bounding_box_min.copy(b_box_min);
        			objMeshes.my_mesh.bounding_box_max.copy(b_box_max);
				
				objMeshes.my_mesh.bounding_box_min.multiplyScalar( modelScale );
				objMeshes.my_mesh.bounding_box_max.multiplyScalar( modelScale );
				
				objMeshes.my_mesh.bounding_box_min.add( modelPositionOffset );
				objMeshes.my_mesh.bounding_box_max.add( modelPositionOffset );
				/*
				for ( var i=0; i < (9*total_number_of_triangles); i++ ){
					console.log(triangle_array[i]);
				}
				*/


				BVH_Build();
				
				
				triangleDataTexture = new THREE.DataTexture( triangle_array, 
									     4096, 
									     1, 
									     THREE.RGBFormat, 
									     THREE.FloatType, 
									     THREE.Texture.DEFAULT_MAPPING, 
									     THREE.ClampToEdgeWrapping, 
									     THREE.ClampToEdgeWrapping, 
									     THREE.NearestFilter, 
									     THREE.NearestFilter, 
									     1, 
									     THREE.LinearEncoding );
				
				triangleDataTexture.flipY = false;
				triangleDataTexture.generateMipmaps = false;
				triangleDataTexture.needsUpdate = true;
				
				aabbDataTexture = new THREE.DataTexture( aabb_array, 
									 4096, 
									 1, 
									 THREE.RGBFormat, 
									 THREE.FloatType, 
									 THREE.Texture.DEFAULT_MAPPING, 
									 THREE.ClampToEdgeWrapping, 
									 THREE.ClampToEdgeWrapping, 
									 THREE.NearestFilter, 
									 THREE.NearestFilter, 
									 1, 
									 THREE.LinearEncoding );
				
				aabbDataTexture.flipY = false;
				aabbDataTexture.generateMipmaps = false;
				aabbDataTexture.needsUpdate = true;
				
				
				
				pathTracingGeometry = new THREE.PlaneBufferGeometry( 2, 2 );

				pathTracingUniforms = {
					
					tPreviousTexture: { type: "t", value: screenTextureRenderTarget.texture },
					tTriangleTexture: { type: "t", value: triangleDataTexture },
					tAABBTexture: { type: "t", value: aabbDataTexture },
					
					uCameraIsMoving: { type: "b1", value: false },
					uCameraJustStartedMoving: { type: "b1", value: false },
					uTime: { type: "f", value: 0.0 },
					uSampleCounter: { type: "f", value: 0.0 },
					uULen: { type: "f", value: 1.0 },
					uVLen: { type: "f", value: 1.0 },
					uApertureSize: { type: "f", value: 0.0 },
					uFocusDistance: { type: "f", value: 100.0 },
					
					uResolution: { type: "v2", value: new THREE.Vector2() },
					
					uMeshBBox_min: { type: "v3", value: objMeshes.my_mesh.bounding_box_min },
					uMeshBBox_max: { type: "v3", value: objMeshes.my_mesh.bounding_box_max },
					uRandomVector: { type: "v3", value: new THREE.Vector3() },
				
					uCameraMatrix: { type: "m4", value: new THREE.Matrix4() },
	
				};
				
				pathTracingDefines = {
					NUMBER_OF_TRIANGLES: total_number_of_triangles,
					NUMBER_OF_NODES: nNodes,
					NUMBER_OF_LEAF_PRIMITIVES: leafSize
				};
			
				pathTracingMaterial = new THREE.ShaderMaterial( {
					uniforms: pathTracingUniforms,
					defines: pathTracingDefines,
					vertexShader: document.getElementById( 'pathTracingVertexShader' ).textContent,
					fragmentShader: document.getElementById( 'pathTracingFragmentShader' ).textContent,
				        depthTest: false,
                                        depthWrite: false
                                } );

				pathTracingMesh = new THREE.Mesh( pathTracingGeometry, pathTracingMaterial );
				pathTracingScene.add( pathTracingMesh );
				
				
				
				// the following keeps the large scene ShaderMaterial quad right in front 
				//   of the camera at all times. This is necessary because without it, the scene 
				//   quad will fall out of view and get clipped when the camera rotates past 180 degrees.
				worldCamera.add( pathTracingMesh );
				
				
				
				screenTextureGeometry = new THREE.PlaneBufferGeometry( 2, 2 );
				
				screenTextureUniforms = {
					tTexture0: { type: "t", value: pathTracingRenderTarget.texture }
				}
				
				screenTextureMaterial = new THREE.ShaderMaterial( {
					uniforms: screenTextureUniforms,
					vertexShader: document.getElementById( 'screenTextureVertexShader' ).textContent,
					fragmentShader: document.getElementById( 'screenTextureFragmentShader' ).textContent,
					depthWrite: false,
					depthTest: false
				} );
				
				screenTextureMesh = new THREE.Mesh(screenTextureGeometry, screenTextureMaterial);
				screenTextureScene.add(screenTextureMesh);
				
				
				
			
				screenOutputGeometry = new THREE.PlaneBufferGeometry( 2, 2 );
				
				screenOutputUniforms = {
					uOneOverSampleCounter: { type: "f", value: 0.0 },
					tTexture0: { type: "t", value: pathTracingRenderTarget.texture }
				}
				
				screenOutputMaterial = new THREE.ShaderMaterial( {
					uniforms: screenOutputUniforms,
					vertexShader: document.getElementById( 'screenOutputVertexShader' ).textContent,
					fragmentShader: document.getElementById( 'screenOutputFragmentShader' ).textContent,
					depthWrite: false,
					depthTest: false
				} );
				
				screenOutputMesh = new THREE.Mesh(screenOutputGeometry, screenOutputMaterial);
				screenOutputScene.add(screenOutputMesh);

				/*
				// Fullscreen API
				document.addEventListener("click", function() {
					
					if ( !document.fullscreenElement && !document.mozFullScreenElement && !document.webkitFullscreenElement ) {

						if (document.documentElement.requestFullscreen) {
							document.documentElement.requestFullscreen();
							
						} else if (document.documentElement.mozRequestFullScreen) {
							document.documentElement.mozRequestFullScreen();
						
						} else if (document.documentElement.webkitRequestFullscreen) {
							document.documentElement.webkitRequestFullscreen();
						
						}

					}
				});
				*/
				
				// onWindowResize() must be at the end of the init() function
				onWindowResize();
				
				// everything is set up, now we can start animating
				animate();
				
			} // end function init()
			
			

			function onWindowResize( event ) {
				
				SCREEN_WIDTH = window.innerWidth;
				SCREEN_HEIGHT = window.innerHeight;
				
				renderer.setPixelRatio(pixelRatio);
				renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
				
				fontAspect = (SCREEN_WIDTH / 175) * (SCREEN_HEIGHT / 200);
				if (fontAspect > 25) fontAspect = 25;
				if (fontAspect < 4) fontAspect = 4;
				fontAspect *= 2;
				
				pathTracingUniforms.uResolution.value.x = SCREEN_WIDTH * pixelRatio;
				pathTracingUniforms.uResolution.value.y = SCREEN_HEIGHT * pixelRatio;
				
				pathTracingRenderTarget.setSize( SCREEN_WIDTH * pixelRatio, SCREEN_HEIGHT * pixelRatio );
				screenTextureRenderTarget.setSize( SCREEN_WIDTH * pixelRatio, SCREEN_HEIGHT * pixelRatio );
				
				worldCamera.aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
				worldCamera.updateProjectionMatrix();
				
				// the following scales all scene objects by the worldCamera's field of view,
				// taking into account the screen aspect ratio and multiplying the uniform uULen,
				// the x-coordinate, by this ratio
				fovScale = worldCamera.fov * 0.5 * (Math.PI / 180.0);
				pathTracingUniforms.uVLen.value = Math.tan(fovScale);
				pathTracingUniforms.uULen.value = pathTracingUniforms.uVLen.value * worldCamera.aspect;
				
				if ( !mouseControl ) {
					
					button1Element.style.display = "";
					button2Element.style.display = "";
					button3Element.style.display = "";
					button4Element.style.display = "";
					button5Element.style.display = "";
					button6Element.style.display = "";
					// check if mobile device is in portrait or landscape mode and position buttons accordingly
					if (SCREEN_WIDTH < SCREEN_HEIGHT) {
						
						button1Element.style.right = 36 + "%";
						button2Element.style.right = 2 + "%";
						button3Element.style.right = 16 + "%";
						button4Element.style.right = 16 + "%";
						button5Element.style.right = 3 + "%";
						button6Element.style.right = 3 + "%";

						button1Element.style.bottom = 5 + "%";
						button2Element.style.bottom = 5 + "%";
						button3Element.style.bottom = 13 + "%";
						button4Element.style.bottom = 2 + "%";
						button5Element.style.bottom = 25 + "%";
						button6Element.style.bottom = 18 + "%";
						
					}
					else {
						
						button1Element.style.right = 22 + "%";
						button2Element.style.right = 3 + "%";
						button3Element.style.right = 11 + "%";
						button4Element.style.right = 11 + "%";
						button5Element.style.right = 3 + "%";
						button6Element.style.right = 3 + "%";

						button1Element.style.bottom = 10 + "%";
						button2Element.style.bottom = 10 + "%";
						button3Element.style.bottom = 26 + "%";
						button4Element.style.bottom = 4 + "%";
						button5Element.style.bottom = 48 + "%";
						button6Element.style.bottom = 34 + "%";
						
					}
					
				} // end if ( !mouseControl ) {
				
			} // end function onWindowResize( event )
			


			function animate() {
				
				requestAnimationFrame( animate );
				
				frameTime = clock.getDelta();
				
				elapsedTime = clock.getElapsedTime() % 1000;
				
				// reset flags
				cameraIsMoving = false;
				cameraJustStartedMoving = false;
				
				// check user controls
				if (mouseControl) {
					// movement detected
					if ( oldYawRotation != cameraControlsYawObject.rotation.y || 
					      oldPitchRotation != cameraControlsPitchObject.rotation.x ) {
	
						cameraIsMoving = true;
					}
					
					// save state for next frame
					oldYawRotation = cameraControlsYawObject.rotation.y;
					oldPitchRotation = cameraControlsPitchObject.rotation.x;
					
				} // end if (mouseControl)
			
				// if not playing on desktop, get input from the mobileJoystickControls
				if ( !mouseControl ) {

					newDeltaX = joystickDeltaX;
					
					if (newDeltaX) {
						
						mobileControlsMoveX = oldDeltaX - newDeltaX;
						// smooth out jerkiness if camera was sitting still 
						if (stillFlagX) {
							mobileControlsMoveX *= 0.1;
							stillFlagX = false;
						}
						// mobileJoystick X movement (left and right) affects camera rotation around the Y axis	
						cameraControlsYawObject.rotation.y += (mobileControlsMoveX) * 0.01;
					}
					
					newDeltaY = joystickDeltaY;
					
					if (newDeltaY) {
						
						mobileControlsMoveY = oldDeltaY - newDeltaY;
						// smooth out jerkiness if camera was sitting still
						if (stillFlagY) {
							mobileControlsMoveY *= 0.1;
							stillFlagY = false;
						}
						// mobileJoystick Y movement (up and down) affects camera rotation around the X axis	
						cameraControlsPitchObject.rotation.x += (mobileControlsMoveY) * 0.01;
					}
					
					// clamp the camera's vertical movement (around the x-axis) to the scene's 'ceiling' and 'floor',
					// so you can't accidentally flip the camera upside down
					cameraControlsPitchObject.rotation.x = Math.max( - PI_2, Math.min( PI_2, cameraControlsPitchObject.rotation.x ) );
					
					// save state for next frame
					oldDeltaX = newDeltaX;
					oldDeltaY = newDeltaY;
					
					// movement detected
					if ( newDeltaX || newDeltaY ) {
						
						cameraIsMoving = true;
					}
					else {
						stillFlagX = true;
						stillFlagY = true;
					}
					
					newPinchWidthX = pinchWidthX;
					newPinchWidthY = pinchWidthY;
					pinchDeltaX = newPinchWidthX - oldPinchWidthX;
					pinchDeltaY = newPinchWidthY - oldPinchWidthY;
					
					if( Math.abs(pinchDeltaX) > Math.abs(pinchDeltaY) ) {
						if (pinchDeltaX < -3) increaseFOV = true;
						if (pinchDeltaX >  3) decreaseFOV = true;
					}
					
					if( Math.abs(pinchDeltaY) >= Math.abs(pinchDeltaX) ) {
						if (pinchDeltaY >  1) increaseAperture = true;
						if (pinchDeltaY < -1) decreaseAperture = true;
					}
					
					// save state for next frame
					oldPinchWidthX = newPinchWidthX;
					oldPinchWidthY = newPinchWidthY;
					
				} // end if ( !mouseControl )
				
				// this gives us a vector in the direction that the camera is pointing,
				// which will be useful for moving the camera 'forward' and shooting projectiles in that direction
				controls.getDirection(cameraDirectionVector);
				cameraDirectionVector.normalize();
				controls.getUpVector(cameraUpVector);
				controls.getRightVector(cameraRightVector);

				// the following gives us a rotation quaternion (4D vector), which will be useful for 
				// rotating scene objects to match the camera's rotation
				worldCamera.getWorldQuaternion(cameraWorldQuaternion);
				
				// allow flying camera
				if ( (keyboard.pressed('W') || button3Pressed) && !(keyboard.pressed('S') || button4Pressed) ) {

					cameraControlsObject.position.add(cameraDirectionVector.multiplyScalar(camFlightSpeed * frameTime));
					cameraIsMoving = true;
				}
				if ( (keyboard.pressed('S') || button4Pressed) && !(keyboard.pressed('W') || button3Pressed) ) {

					cameraControlsObject.position.sub(cameraDirectionVector.multiplyScalar(camFlightSpeed * frameTime));
					cameraIsMoving = true;
				}
				if ( (keyboard.pressed('A') || button1Pressed) && !(keyboard.pressed('D') || button2Pressed) ) {

					cameraControlsObject.position.sub(cameraRightVector.multiplyScalar(camFlightSpeed * frameTime));
					cameraIsMoving = true;
				}
				if ( (keyboard.pressed('D') || button2Pressed) && !(keyboard.pressed('A') || button1Pressed) ) {

					cameraControlsObject.position.add(cameraRightVector.multiplyScalar(camFlightSpeed * frameTime));
					cameraIsMoving = true;
				}
				if ( keyboard.pressed('Q') && !keyboard.pressed('Z') ) {

					cameraControlsObject.position.add(cameraUpVector.multiplyScalar(camFlightSpeed * frameTime));
					cameraIsMoving = true;
				}
				if ( keyboard.pressed('Z') && !keyboard.pressed('Q') ) {

					cameraControlsObject.position.sub(cameraUpVector.multiplyScalar(camFlightSpeed * frameTime));
					cameraIsMoving = true;
				}
				if ( (keyboard.pressed('up') || button5Pressed) && !(keyboard.pressed('down') || button6Pressed) ) {
					
					increaseFocusDist = true;
				}
				if ( (keyboard.pressed('down') || button6Pressed) && !(keyboard.pressed('up') || button5Pressed) ) {
					
					decreaseFocusDist = true;
				}
				if ( keyboard.pressed('right') && !keyboard.pressed('left') ) {
					
					increaseAperture = true;
				}
				if ( keyboard.pressed('left') && !keyboard.pressed('right') ) {
					
					decreaseAperture = true;
				}
				
				if ( increaseFOV ) {
					worldCamera.fov ++;
					if (worldCamera.fov > 150)
						worldCamera.fov = 150;
					fovScale = worldCamera.fov * 0.5 * (Math.PI / 180.0);
					pathTracingUniforms.uVLen.value = Math.tan(fovScale);
					pathTracingUniforms.uULen.value = pathTracingUniforms.uVLen.value * worldCamera.aspect;
				
					cameraIsMoving = true;
					increaseFOV = false;
				}
				if ( decreaseFOV ) {
					worldCamera.fov --;
					if (worldCamera.fov < 1)
						worldCamera.fov = 1;
					fovScale = worldCamera.fov * 0.5 * (Math.PI / 180.0);
					pathTracingUniforms.uVLen.value = Math.tan(fovScale);
					pathTracingUniforms.uULen.value = pathTracingUniforms.uVLen.value * worldCamera.aspect;
					
					cameraIsMoving = true;
					decreaseFOV = false;
				}
				
				if (increaseFocusDist) {
					focusDistance ++;
					pathTracingUniforms.uFocusDistance.value = focusDistance;
					cameraIsMoving = true;
					increaseFocusDist = false;
				}
				if (decreaseFocusDist) {
					focusDistance --;
					if (focusDistance < 1)
						focusDistance = 1;
					pathTracingUniforms.uFocusDistance.value = focusDistance;
					cameraIsMoving = true;
					decreaseFocusDist = false;
				}
				
				if (increaseAperture) {
					apertureSize += 0.1;
					if (apertureSize > 20.0)
						apertureSize = 20.0;
					pathTracingUniforms.uApertureSize.value = apertureSize;
					cameraIsMoving = true;
					increaseAperture = false;
				}
				if (decreaseAperture) {
					apertureSize -= 0.1;
					if (apertureSize < 0.0)
						apertureSize = 0.0;
					pathTracingUniforms.uApertureSize.value = apertureSize;
					cameraIsMoving = true;
					decreaseAperture = false;
				}
				
				
				if ( cameraIsMoving ) {
					
					sampleCounter = 1.0;
					
					if ( !cameraRecentlyMoving ) {
						cameraJustStartedMoving = true;
						cameraRecentlyMoving = true;
					}
					
				}
				
				if ( !cameraIsMoving ) {
	
					sampleCounter += 1.0;
					cameraRecentlyMoving = false;
					
				}
					
				
				pathTracingUniforms.uCameraIsMoving.value = cameraIsMoving;
				pathTracingUniforms.uCameraJustStartedMoving.value = cameraJustStartedMoving;
				pathTracingUniforms.uSampleCounter.value = sampleCounter;
				screenOutputUniforms.uOneOverSampleCounter.value = 1.0 / sampleCounter;
				pathTracingUniforms.uRandomVector.value = randomVector.set( Math.random(), Math.random(), Math.random() );
				// CAMERA
				cameraControlsObject.updateMatrixWorld(true);			
				pathTracingUniforms.uCameraMatrix.value.copy( worldCamera.matrixWorld );
				
				cameraInfoElement.innerHTML = "FOV: " + worldCamera.fov + " / Aperture: " + apertureSize.toFixed(2) + " / FocusDistance: " + focusDistance + "<br>" + "Samples: " + sampleCounter;
				
				
				// RENDERING in 3 steps
				
				// STEP 1
				// Perform PathTracing and Render(save) into pathTracingRenderTarget
				// Read previous screenTextureRenderTarget to use as a new starting point to blend with
				renderer.render( pathTracingScene, worldCamera, pathTracingRenderTarget );	
				
				// STEP 2
				// Render(copy) the final pathTracingScene output(above) into screenTextureRenderTarget
				// This will be used as a new starting point for Step 1 above
				renderer.render( screenTextureScene, quadCamera, screenTextureRenderTarget );
				
				// STEP 3
				// Render full screen quad with generated pathTracingRenderTarget in STEP 1 above.
				// After the image is gamma corrected, it will be shown on the screen as the final accumulated output
				renderer.render( screenOutputScene, quadCamera );
						
				
				stats.update();
					
			
			} // end function animate()
			
		</script>

	</body>
</html>
