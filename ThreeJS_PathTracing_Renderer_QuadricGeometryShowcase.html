<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js PathTracing Renderer - Quadric Geometry Showcase</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1">
		<style>

			html, body {
				width: 100%;
				height: 100%;
				font-family: Monospace;
				background-color: #000;
				color: #000;
				margin: 0px;
				overflow: hidden;
			}
			
			#info {
				position: absolute;
				top: 5px;
				width: 100%;
				text-align: center;
				color: #ffffff;
			}		
			
		</style>
	</head>
	<body>
		
		<div id="container"> </div>
		<div id="info">three.js PathTracing Renderer - Quadric Geometry Showcase</div>
		
		<div id="cameraInfo" style="position:fixed; left:3%; bottom:2%; font-family:arial; font-type:bold; color:rgb(255,255,255);">
		FOV: 55 / Aperture: 0.00 / FocusDistance: 132 <br> 
		Samples: 0
		</div>
		
		<script src="js/three-r84.min.js"> </script>
		<script src="js/threex.keyboardstate.js"> </script>
		<script src="js/FirstPersonCameraControls.js"> </script>
		<script src="js/MobileJoystickControls.js"> </script>
		<!-- <script src="js/webgl-obj-loader.js"> </script> -->
		<script src="js/Detector.js"> </script>
		<script src="js/stats.min.js"> </script>
		
		
		<script id="screenTextureVertexShader" type="x-shader/x-vertex">
		
precision highp float;
precision highp int;

varying vec2 vUv;

void main()
{
	vUv = uv;
	gl_Position = vec4( position, 1.0 );

}

		</script>
		
		<script id="screenTextureFragmentShader" type="x-shader/x-fragment">

precision highp float;
precision highp int;
precision highp sampler2D;

varying vec2 vUv;
uniform sampler2D tTexture0;


void main()
{	
	gl_FragColor = texture2D(tTexture0, vUv);	
}
		
		</script>
		
		<script id="screenOutputVertexShader" type="x-shader/x-vertex">

precision highp float;
precision highp int;

varying vec2 vUv;

void main() 
{
	vUv = uv;
	gl_Position = vec4( position, 1.0 );
}

		</script>
		
		<script id="screenOutputFragmentShader" type="x-shader/x-fragment">

precision highp float;
precision highp int;
precision highp sampler2D;

varying vec2 vUv;
uniform float uOneOverSampleCounter;
uniform sampler2D tTexture0;

void main()
{
	vec4 pixelColor = texture2D(tTexture0, vUv) * uOneOverSampleCounter;
	
	gl_FragColor = sqrt(pixelColor);	
}
		
		</script>
		


		<script id="pathTracingVertexShader" type="x-shader/x-vertex">
		
precision highp float;
precision highp int;

varying vec2 vUv;

void main()
{
	vUv = uv;
	gl_Position = vec4( position, 1.0 );
}

		</script>
		
		
		
		<script id="pathTracingFragmentShader" type="x-shader/x-fragment">
				
precision highp float;
precision highp int;
precision highp sampler2D;


uniform bool uCameraIsMoving;
uniform bool uCameraJustStartedMoving;

uniform float uTime;
uniform float uSampleCounter;
uniform float uULen;
uniform float uVLen;
uniform float uApertureSize;
uniform float uFocusDistance;

uniform vec2 uResolution;

//uniform vec3 uMeshBBox_min;
//uniform vec3 uMeshBBox_max;

uniform vec3 uRandomVector;

uniform mat4 uCameraMatrix;
//uniform mat4 uSphereMeshesMatrix[4];

uniform sampler2D tPreviousTexture;
//uniform sampler2D tTriangleTexture;

varying vec2 vUv;

#define PI               3.14159265358979323
#define ONE_OVER_PI      0.31830988618379067
#define TWO_PI           6.28318530717958648
#define FOUR_PI          12.5663706143591729
#define ONE_OVER_FOUR_PI 0.07957747154594767
#define PI_OVER_TWO      1.57079632679489662
#define ONE_OVER_THREE   0.33333333333333333
#define E                2.71828182845904524
#define INFINITY         1000000.0

#define SPHERE_ID 0
#define PLANE_ID 1
#define DISK_ID 2
#define TRIANGLE_ID 3
#define QUAD_ID 4
#define BOX_ID 5
#define ELLIPSOID_ID 6
#define PARABOLOID_ID 7
#define HYPERBOLICPARABOLOID_ID 8
#define HYPERBOLOID_ID 9
#define CYLINDER_ID 10
#define CLOSEDCYLINDER_ID 11
#define CONE_ID 12
#define CAPSULE_ID 13
#define TORUS_ID 14
#define OBJ_TRIANGLE_ID 15

#define N_SPHERES 5
#define N_PLANES 1
#define N_DISKS 1
#define N_TRIANGLES 1
#define N_QUADS 1
#define N_BOXES 2
#define N_ELLIPSOIDS 2
#define N_PARABOLOIDS 1
#define N_HYPERBOLICPARABOLOIDS 1
#define N_HYPERBOLOIDS 1
#define N_CYLINDERS 1
#define N_CLOSEDCYLINDERS 1
#define N_CONES 1
#define N_CAPSULES 1
#define N_TORII 1

#define LIGHT 0
#define DIFF 1
#define REFR 2
#define SPEC 3
#define CHECK 4
#define COAT 5
#define VOLUME 6
#define TRANSLUCENT 7
#define SPECSUB 8


float seed = 0.0;

float hash21(vec2 p)
{
	float h = dot(p,vec2(127.1,311.7));
	
	return fract(sin(h)*43758.5453123);
}

float noise3D(vec3 p)
{
	return fract(sin(dot(p ,vec3(12.9898,78.233,128.852))) * 43758.5453);
}

float rand()
{ 
	seed -= uRandomVector.x * uRandomVector.y;
	return fract( sin( seed ) * 43758.5453123 );
}


//-----------------------------------------------------------------------

struct Ray { vec3 origin; vec3 direction; };
struct Sphere { float radius; vec3 position; vec3 emission; vec3 color; int type; };
struct Ellipsoid { vec3 radii; vec3 position; vec3 emission; vec3 color; int type; };
struct Paraboloid { float rad; float height; vec3 pos; vec3 emission; vec3 color; int type; };
struct HyperbolicParaboloid { float rad; float height; vec3 pos; vec3 emission; vec3 color; int type; };
struct Hyperboloid { float rad; float height; vec3 pos; vec3 emission; vec3 color; int type; };
struct Cylinder { float radius; float height; vec3 position; vec3 emission; vec3 color; int type; };
struct ClosedCylinder { float radius; vec3 cap1pos; vec3 cap2pos; vec3 emission; vec3 color; int type; };
struct Cone { vec3 pos0; float radius0; vec3 pos1; float radius1; vec3 emission; vec3 color; int type; };
struct Capsule { vec3 pos0; float radius0; vec3 pos1; float radius1; vec3 emission; vec3 color; int type; };
struct Torus { vec3 pos; float radius0; float radius1; vec3 emission; vec3 color; int type; };
//struct Plane { vec4 pla; vec3 emission; vec3 color; int type; };
struct Disk { float radiusSq; vec3 pos; vec3 normal; vec3 emission; vec3 color; int type; };
//struct Triangle { vec3 normal; vec3 v0; vec3 v1; vec3 v2; vec3 emission; vec3 color; int type; };
//struct Quad { vec3 normal; vec3 v0; vec3 v1; vec3 v2; vec3 v3; vec3 emission; vec3 color; int type; };
struct Box { vec3 minCorner; vec3 maxCorner; vec3 emission; vec3 color; int type; };
struct Intersection { vec3 normal; vec3 emission; vec3 color; int type; int id; };

Sphere spheres[N_SPHERES];
Ellipsoid ellipsoids[N_ELLIPSOIDS];
Paraboloid paraboloids[N_PARABOLOIDS];
HyperbolicParaboloid hyperbolicParaboloids[N_HYPERBOLICPARABOLOIDS];
Hyperboloid hyperboloids[N_HYPERBOLOIDS];
Cylinder cylinders[N_CYLINDERS];
ClosedCylinder closedCylinders[N_CLOSEDCYLINDERS];
Cone cones[N_CONES];
Capsule capsules[N_CAPSULES];
Torus torii[N_TORII];
//Plane planes[N_PLANES];
Disk disks[N_DISKS];
//Triangle triangles[N_TRIANGLES];
//Quad quads[N_QUADS];
Box boxes[N_BOXES];



//-----------------------------------------------------------------------
float SphereIntersect( float rad, vec3 pos, Ray r )
//-----------------------------------------------------------------------
{
	vec3 op = r.origin - pos;
	float b = dot(op, r.direction);
	float det = b * b - dot(op,op) + rad * rad;
	if (det < 0.0)
		return INFINITY;
        
	det = sqrt(det);	
	float t1 = -b - det;
	if( t1 > 0.0 )
		return t1;
		
	float t2 = -b + det;
	if( t2 > 0.0 )
		return t2;
		
	return INFINITY;	
}

//-----------------------------------------------------------------------
float EllipsoidIntersect( vec3 radii, vec3 pos, Ray r )
//-----------------------------------------------------------------------
{
	vec3 oc = r.origin - pos;
	vec3 oc2 = oc*oc;
	vec3 ocrd = oc*r.direction;
	vec3 rd2 = r.direction*r.direction;
	vec3 invRad = 1.0/radii;
	vec3 invRad2 = invRad*invRad;
	
	// quadratic equation coefficients
	float a = dot(rd2, invRad2);
	float b = 2.0*dot(ocrd, invRad2);
	float c = dot(oc2, invRad2) - 1.0;
	float det = b*b - 4.0*a*c;
	if (det < 0.0) 
		return INFINITY;
		
	det = sqrt(det);
	float t1 = (-b - det) / (2.0 * a);
	if( t1 > 0.0 )
		return t1;
		
	float t2 = (-b + det) / (2.0 * a);
	if( t2 > 0.0 )
		return t2;
	
	return INFINITY;	
}

//------------------------------------------------------------------------------
float ParaboloidIntersect( float rad, float height, vec3 pos, Ray r, out vec3 n )
//------------------------------------------------------------------------------
{
	vec3 rd = r.direction;
	vec3 ro = r.origin - pos;
	float k = height / (rad * rad);
	
	// quadratic equation coefficients
	float a = k * (rd.x * rd.x + rd.z * rd.z);
	float b = k * 2.0 * (rd.x * ro.x + rd.z * ro.z) - rd.y;
	float c = k * (ro.x * ro.x + ro.z * ro.z) - ro.y;
	float det = (b * b) - (4.0 * a * c);
	if (det < 0.0) 
		return INFINITY;
		
	det = sqrt(det);
	float t1 = (-b - det) / (2.0 * a);
	float t2 = (-b + det) / (2.0 * a);
	float result = INFINITY;
	vec3 ip1 = ro + rd * t1;
	vec3 ip2 = ro + rd * t2;
	
	if (t2 > 0.0)
	{	
		if (abs(ip2.y) < height)
		{
			n = vec3( -2.0 * ip2.x, 1.0, -2.0 * ip2.z );
			result = t2;
		}		
	}
	
	if (t1 > 0.0)
	{
		if (abs(ip1.y) < height)
		{
			n = vec3( 2.0 * ip1.x, -1.0, 2.0 * ip1.z );
			result = t1;
		}		
	}
	
	if( t1 > 0.0 && t2 > 0.0)
	{
		float dist1 = distance(ro,ip1);
		float dist2 = distance(ro,ip2);
		
		if (dist2 < dist1 && abs(ip2.y) < height)
		{
			n = vec3( -2.0 * ip2.x, 1.0, -2.0 * ip2.z );
			result = t2;
		}	
		
		else if (abs(ip1.y) < height)
		{
			n = vec3( 2.0 * ip1.x, -1.0, 2.0 * ip1.z );
			result = t1;
		}			
	}
		
	return result;	
}


//-----------------------------------------------------------------------------------------
float HyperbolicParaboloidIntersect( float rad, float height, vec3 pos, Ray r, out vec3 n )
//-----------------------------------------------------------------------------------------
{
	vec3 rd = r.direction;
	vec3 ro = r.origin - pos;
	float k = height / (rad * rad);
	
	// quadratic equation coefficients
	float a = k * (rd.x * rd.x - rd.z * rd.z);
	float b = k * 2.0 * (rd.x * ro.x - rd.z * ro.z) - rd.y;
	float c = k * (ro.x * ro.x - ro.z * ro.z) - ro.y;
	
	float det = (b * b) - (4.0 * a * c);
	if (det < 0.0) 
		return INFINITY;
		
	det = sqrt(det);
	float t1 = (-b - det) / (2.0 * a);
	float t2 = (-b + det) / (2.0 * a);
	float result = INFINITY;
	vec3 ip1 = ro + rd * t1;
	vec3 ip2 = ro + rd * t2;
	
	if (t2 > 0.0)
	{	
		if (abs(ip2.x) < height && abs(ip2.y) < height && abs(ip2.z) < height)
		{
			n = vec3( -2.0 * ip2.x, 1.0, 2.0 * ip2.z );
			result = t2;
		}		
	}
	
	if (t1 > 0.0)
	{
		if (abs(ip1.x) < height && abs(ip1.y) < height && abs(ip1.z) < height)
		{
			n = vec3( 2.0 * ip1.x, -1.0, -2.0 * ip1.z );
			result = t1;
		}		
	}
	
	if( t1 > 0.0 && t2 > 0.0)
	{
		float dist1 = distance(ro,ip1);
		float dist2 = distance(ro,ip2);
		
		if (dist2 < dist1 && abs(ip2.x) < height && abs(ip2.y) < height && abs(ip2.z) < height)
		{
			n = vec3( -2.0 * ip2.x, 1.0, 2.0 * ip2.z );
			result = t2;
		}	
		
		else if (abs(ip1.x) < height && abs(ip1.y) < height && abs(ip1.z) < height)
		{
			n = vec3( 2.0 * ip1.x, -1.0, -2.0 * ip1.z );
			result = t1;
		}			
	}
		
	return result;	
}

//-------------------------------------------------------------------------------
float HyperboloidIntersect( float rad, float height, vec3 pos, Ray r, out vec3 n )
//-------------------------------------------------------------------------------
{
	vec3 rd = r.direction;
	vec3 ro = r.origin - pos;
	float k = height / (rad * rad);
	
	// quadratic equation coefficients
	float a = k * ((rd.x * rd.x) - (rd.y * rd.y) + (rd.z * rd.z));
	float b = k * 2.0 * ( (rd.x * ro.x) - (rd.y * ro.y) + (rd.z * ro.z) );
	float c = k * ((ro.x * ro.x) - (ro.y * ro.y) + (ro.z * ro.z)) - (rad * rad);
	float det = (b * b) - (4.0 * a * c);
	if (det < 0.0) 
		return INFINITY;
		
	det = sqrt(det);
	float t1 = (-b - det) / (2.0 * a);
	float t2 = (-b + det) / (2.0 * a);
	float result = INFINITY;
	vec3 ip1 = ro + rd * t1;
	vec3 ip2 = ro + rd * t2;
	
	if (t2 > 0.0)
	{	
		if (abs(ip2.y) < height)
		{
			n = vec3( -2.0 * ip2.x, 2.0 * ip2.y, -2.0 * ip2.z );
			result = t2;
		}		
	}
	
	if (t1 > 0.0)
	{
		if (abs(ip1.y) < height)
		{
			n = vec3( 2.0 * ip1.x, -2.0 * ip1.y, 2.0 * ip1.z );
			result = t1;
		}		
	}
	
	if( t1 > 0.0 && t2 > 0.0)
	{
		float dist1 = distance(ro,ip1);
		float dist2 = distance(ro,ip2);
		
		if (dist2 < dist1 && abs(ip2.y) < height)
		{
			n = vec3( -2.0 * ip2.x, 2.0 * ip2.y, -2.0 * ip2.z );
			result = t2;
		}	
		
		else if (abs(ip1.y) < height)
		{
			n = vec3( 2.0 * ip1.x, -2.0 * ip1.y, 2.0 * ip1.z );
			result = t1;
		}			
	}
	
	return result;	
}

//-----------------------------------------------------------------------
float CylinderIntersect( vec3 p0, vec3 p1, float rad, Ray r, out vec3 n )
//-----------------------------------------------------------------------
{
	float r2=rad*rad;
	
	vec3 dp=p1-p0;
	vec3 dpt=dp/dot(dp,dp);
	
	vec3 ao=r.origin-p0;
	vec3 aoxab=cross(ao,dpt);
	vec3 vxab=cross(r.direction,dpt);
	float ab2=dot(dpt,dpt);
	float a=2.0*dot(vxab,vxab);
	float ra=1.0/a;
	float b=2.0*dot(vxab,aoxab);
	float c=dot(aoxab,aoxab)-r2*ab2;
	
	float det=b*b-2.0*a*c;
	
	if(det<0.0)
	return INFINITY;
	
	det=sqrt(det);
	
	float t = INFINITY;
	
	float t0=(-b-det)*ra;
	float t1=(-b+det)*ra;
	
	vec3 ip;
	vec3 lp;
	float ct;
	
	if (t1 > 0.0)
	{
		ip=r.origin+r.direction*t1;
		lp=ip-p0;
		ct=dot(lp,dpt);
		if((ct>0.0)&&(ct<1.0))
		{
			t = t1;
		     	n=(p0+dp*ct)-ip;
		}
		
	}
	
	if (t0 > 0.0)
	{
		ip=r.origin+r.direction*t0;
		lp=ip-p0;
		ct=dot(lp,dpt);
		if((ct>0.0)&&(ct<1.0))
		{
			t = t0;
			n=ip-(p0+dp*ct);
		}
		
	}
	
	return t;
}

/*
//-----------------------------------------------------------------------------
float CappedCylinderIntersect( vec3 p0, vec3 p1, float rad, Ray r, out vec3 n )
//-----------------------------------------------------------------------------
{
	float r2=rad*rad;
	
	vec3 dp=p1-p0;
	vec3 dpt=dp/dot(dp,dp);
	
	vec3 ao=r.origin-p0;
	vec3 aoxab=cross(ao,dpt);
	vec3 vxab=cross(r.direction,dpt);
	float ab2=dot(dpt,dpt);
	float a=2.0*dot(vxab,vxab);
	float ra=1.0/a;
	float b=2.0*dot(vxab,aoxab);
	float c=dot(aoxab,aoxab)-r2*ab2;
	
	float det=b*b-2.0*a*c;
	
	if(det<0.0)
		return INFINITY;
	
	det=sqrt(det);
	
	float t0=(-b-det)*ra;
	float t1=(-b+det)*ra;
	
	vec3 ip;
	vec3 lp;
	float ct;
	float result = INFINITY;
	
	// Cylinder caps
	// disk0
	vec3 diskNormal = normalize(dp);
	float denom = dot(diskNormal, r.direction);
	vec3 pOrO = p0 - r.origin;
	float tDisk0 = dot(pOrO, diskNormal) / denom;
	if (tDisk0 > 0.0)
	{
		vec3 intersectPos = r.origin + r.direction * tDisk0;
		vec3 v = intersectPos - p0;
		float d2 = dot(v,v);
		if (d2 <= r2)
		{
			result = tDisk0;
			n = diskNormal;
		}
	}
	
	// disk1
	denom = dot(diskNormal, r.direction);
	pOrO = p1 - r.origin;
	float tDisk1 = dot(pOrO, diskNormal) / denom;
	if (tDisk1 > 0.0)
	{
		vec3 intersectPos = r.origin + r.direction * tDisk1;
		vec3 v = intersectPos - p1;
		float d2 = dot(v,v);
		if (d2 <= r2 && tDisk1 < result)
		{
			result = tDisk1;
			n = diskNormal;
		}
	}
		
	// Cylinder body
	if (t1 > 0.0)
	{
		ip=r.origin+r.direction*t1;
		lp=ip-p0;
		ct=dot(lp,dpt);
		if(ct>0.0 && ct<1.0 && t1<result)
		{
			result = t1;
		     	n=(p0+dp*ct)-ip;
		}
		
	}
	
	if (t0 > 0.0)
	{
		ip=r.origin+r.direction*t0;
		lp=ip-p0;
		ct=dot(lp,dpt);
		if(ct>0.0 && ct<1.0 && t0<result)
		{
			result = t0;
			n=ip-(p0+dp*ct);
		}
		
	}
	
	return result;
}
*/

vec4 iCylinder( vec3 ro, vec3 rd, vec3 pa, vec3 pb, float ra )
{
	vec3 cc = 0.5*(pa+pb);
	float ch = length(pb-pa);
	vec3 ca = (pb-pa)/ch;
	ch *= 0.5;
	
	vec3  oc = ro - cc;
	
	float card = dot(ca,rd);
	float caoc = dot(ca,oc);
	
	float a = 1.0 - card*card;
	float b = dot( oc, rd) - caoc*card;
	float c = dot( oc, oc) - caoc*caoc - ra*ra;
	float h = b*b - a*c;
	if( h<0.0 ) 
		return vec4(INFINITY);
	h = sqrt(h);
	float t1 = (-b-h)/a;
	float t2 = (-b+h)/a;
	
	float y = caoc + t1*card;
	
	// body
	if( abs(y)<ch ) 
		return vec4( t1, oc+t1*rd - ca*y );
		
	// caps
	float sy = sign(y);
	float tp = (sy*ch - caoc)/card;
	if( tp>t1 && tp<t2 )
	{
		return vec4( tp, ca*sy );
	}
	
	return vec4(INFINITY);
}

//----------------------------------------------------------------------------
float ConeIntersect( vec3 p0, float r0, vec3 p1, float r1, Ray r, out vec3 n )
//----------------------------------------------------------------------------   
{
	r0 += 0.1;
	float t = INFINITY;
	vec3 locX;
	vec3 locY;
	vec3 locZ=-(p1-p0)/(1.0 - r1/r0);
	
	Ray ray = r;
	ray.origin-=p0-locZ;
	
	if(abs(locZ.x)<abs(locZ.y))
		locX=vec3(1,0,0);
	else
		locX=vec3(0,1,0);
		
	float len=length(locZ);
	locZ=normalize(locZ)/len;
	locY=normalize(cross(locX,locZ))/r0;
	locX=normalize(cross(locY,locZ))/r0;
	
	mat3 tm;
	tm[0]=locX;
	tm[1]=locY;
	tm[2]=locZ;
	
	ray.direction*=tm;
	ray.origin*=tm;
	
	float dx=ray.direction.x;
	float dy=ray.direction.y;
	float dz=ray.direction.z;
	
	float x0=ray.origin.x;
	float y0=ray.origin.y;
	float z0=ray.origin.z;
	
	float x02=x0*x0;
	float y02=y0*y0;
	float z02=z0*z0;
	
	float dx2=dx*dx;
	float dy2=dy*dy;
	float dz2=dz*dz;
	
	float det=(
		-2.0*x0*dx*z0*dz
        +2.0*x0*dx*y0*dy
        -2.0*z0*dz*y0*dy
        +dz2*x02
        +dz2*y02
        +dx2*z02
        +dy2*z02
        -dy2*x02
        -dx2*y02
        );
	
	if(det<0.0)
		return INFINITY;
		
	float t0=(-x0*dx+z0*dz-y0*dy-sqrt(abs(det)))/(dx2-dz2+dy2);
	float t1=(-x0*dx+z0*dz-y0*dy+sqrt(abs(det)))/(dx2-dz2+dy2);
	vec3 pt0=ray.origin+t0*ray.direction;
	vec3 pt1=ray.origin+t1*ray.direction;
	
        if(t1>0.0 && pt1.z>r1/r0 && pt1.z<1.0)
	{
		t=t1;
		n=pt1;
		n.z=0.0;
		n=normalize(n);
		n.z=-pt1.z/abs(pt1.z);
		n=normalize(n);
		n=tm*-n;
	}
	
	if(t0>0.0 && pt0.z>r1/r0 && pt0.z<1.0)
	{
		t=t0;
		n=pt0;
		n.z=0.0;
		n=normalize(n);
		n.z=-pt0.z/abs(pt0.z);
		n=normalize(n);
		n=tm*n;
	}
	
	return t;	
}

//-------------------------------------------------------------------------------
float CapsuleIntersect( vec3 p0, float r0, vec3 p1, float r1, Ray r, out vec3 n )
//-------------------------------------------------------------------------------
{
	/*
	vec3 l  = p1-p0;
	float ld = length(l);
	l=l/ld;
	float d= r0-r1;
	float sa = d/ld;
	float h0 = r0*sa;
	float h1 = r1*sa;
	float cr0 = sqrt(r0*r0-h0*h0);
	float cr1 = sqrt(r1*r1-h1*h1);
	vec3 coneP0=p0+l*h0;
	vec3 coneP1=p1+l*h1;
	*/
	
	float t0=INFINITY;
	    
	float t1;
	vec3 uv1;
	vec3 n1;
	//t1 = ConeIntersect(coneP0,cr0,coneP1,cr1,r,n1);
	t1 = CylinderIntersect(p0,p1,r0,r,n1);
	if(t1<t0)
	{
		t0=t1;
		n=n1;
	}
	t1 = SphereIntersect(r0,p0,r);
	if(t1<t0)
	{
		t0=t1;
		n=(r.origin + r.direction * t1) - p0;
	}
	t1 = SphereIntersect(r1,p1,r);
	if(t1<t0)
	{
		t0=t1;
		n=(r.origin + r.direction * t1) - p1;
	}
	    
	return t0;
}

//-----------------------------------------------------------------------
float TorusIntersect( vec3 pos, float rad0, float rad1, Ray ray )
//-----------------------------------------------------------------------
{
	vec3 rO = ray.origin;
	vec3 rD = ray.direction;
	
	float Ra2 = rad0*rad0;
	float ra2 = rad1*rad1;
	
	float m = dot(rO,rO);
	float n = dot(rO,rD);
		
	float k = (m - ra2 - Ra2) * 0.5;
	float a = n;
	float b = n*n + Ra2*rD.z*rD.z + k;
	float c = k*n + Ra2*rO.z*rD.z;
	float d = k*k + Ra2*rO.z*rO.z - Ra2*ra2;
	
	float a2 = a * a;
	float p = -3.0*a2     + 2.0*b;
	float q =  2.0*a2*a   - 2.0*a*b   + 2.0*c;
	float r = -3.0*a2*a2 + 4.0*a2*b - 8.0*a*c + 4.0*d;
	p *= ONE_OVER_THREE;
	r *= ONE_OVER_THREE;
	float p2 = p * p;
	float Q = p2 + r;
	float R = 3.0*r*p - p2*p - q*q;
	
	float h = R*R - Q*Q*Q;
	float z = 0.0;
	if( h < 0.0 )
	{
		float sQ = sqrt(Q);
		z = 2.0*sQ*cos( acos(R/(sQ*Q)) * ONE_OVER_THREE );
	}
	else
	{
		float sQ = pow( sqrt(h) + abs(R), ONE_OVER_THREE );
		z = sign(R)*abs( sQ + Q/sQ );
	}
	
	z = p - z;
		
	float d1 = z   - 3.0*p;
	float d2 = z*z - 3.0*r;

	if( abs(d1)<0.0001 )
	{
		if( d2<0.0 ) return INFINITY;
		d2 = sqrt(d2);
	}
	else
	{
		if( d1<0.0 ) return INFINITY;
		d1 = sqrt( d1*0.5 );
		d2 = q/d1;
	}
	
	float result = INFINITY;
	float d1SqMinusZ = d1*d1 - z;
	h = d1SqMinusZ + d2;
	if( h>0.0 )
	{
		h = sqrt(h);
		float t1 = -d1 - h - a;
		float t2 = -d1 + h - a;
		if( t1>0.0 ) result=t1;
		else if( t2>0.0 ) result=t2;
	}

	h = d1SqMinusZ - d2;
	if( h>0.0 )
	{
		h = sqrt(h);
		float t1 = d1 - h - a;
		float t2 = d1 + h - a;
		if( t1>0.0 ) result=min(result,t1);
		else if( t2>0.0 ) result=min(result,t2);
	}

	return result;
}

/*
//-----------------------------------------------------------------------
float PlaneIntersect( vec4 pla, Ray r )
//-----------------------------------------------------------------------
{
	vec3 n = normalize(-pla.xyz);
	float denom = dot(n, r.direction);
	if (denom <= 0.0)
		return INFINITY;
	
        vec3 pOrO = (pla.w * n) - r.origin; 
        return dot(pOrO, n) / denom; 
}
*/

/*
//-----------------------------------------------------------------------
float DiskIntersect( float radiusSq, vec3 diskPos, vec3 normal, Ray r )
//-----------------------------------------------------------------------
{
	vec3 n = normalize(-normal);
	float denom = dot(n, r.direction);
	if (denom <= 0.0)
		return INFINITY;
	 	
	vec3 pOrO = diskPos - r.origin;
        float t = dot(pOrO, n) / denom;
	if (t < 0.0)
		return INFINITY;
        vec3 intersectPos = r.origin + r.direction * t;
	vec3 v = intersectPos - diskPos;
	float d2 = dot(v,v);
	if (d2 > radiusSq)
		return INFINITY;
		
	return t;
}
*/

/*
float RayTriangleIntersection( Ray r, vec3 v0, vec3 edge1, vec3 edge2 )
{
	vec3 tvec = r.origin - v0;
	vec3 pvec = cross(r.direction, edge2);
	float det = dot(edge1, pvec);
	
	det = 1.0 / det; 
	
	float u = dot(tvec, pvec) * det;
	
	if (u < 0.0 || u > 1.0)
		return INFINITY;
		
	vec3 qvec = cross(tvec, edge1);
	
	float v = dot(r.direction, qvec) * det;
	
	if (v < 0.0 || (u + v) > 1.0)
		return INFINITY;
		
	return dot(edge2, qvec) * det;
}
*/

/*
vec3 getTriangleNormal( int triangleIndex )
{		
	vec3 edge1;
	vec3 edge2;
	float InvWidth = 0.00024414062;
	float iX9 = float(triangleIndex) * 9.0;
			      
	edge1 = vec3( texture2D(tTriangleTexture, vec2( (iX9 + 3.0) * InvWidth, 0) ).a,
		      texture2D(tTriangleTexture, vec2( (iX9 + 4.0) * InvWidth, 0) ).a,
		      texture2D(tTriangleTexture, vec2( (iX9 + 5.0) * InvWidth, 0) ).a );
			      
	edge2 = vec3( texture2D(tTriangleTexture, vec2( (iX9 + 6.0) * InvWidth, 0) ).a,
		      texture2D(tTriangleTexture, vec2( (iX9 + 7.0) * InvWidth, 0) ).a,
	              texture2D(tTriangleTexture, vec2( (iX9 + 8.0) * InvWidth, 0) ).a );
		      
	vec3 trinormal = cross(edge1, edge2);
	trinormal = normalize(trinormal);
	
	return trinormal;
}
*/

/*
//-------------------------------------------------------------------------------
float ArenbergTriangleIntersect( vec3 p0, vec3 v0, vec3 v1, vec3 v2, Ray r )
//-------------------------------------------------------------------------------
{
	// from Jeff Arenberg's response to Rod Bogart's initial post (Ray/Triangle Intersection with Barycentric Coordinates)
	// in the November 4, 1988 issue of Ray Tracing News, Volume 1, Number 11
	// http://oldwww.acm.org/tog/resources/RTNews/html/rtnews5b.html#art3
	
	float Den = dot(r.direction, v2);
        if (Den <= 0.0) return INFINITY;
	
	float Num = dot( (p0 - r.origin), v2 );
	float t = Num / Den;
	if (t < 0.0) return INFINITY;
	
        vec3 p = t * r.direction + r.origin - p0;
	float a = dot(p, v0);
	float b = dot(p, v1);
	if (a < 0.0 || b < 0.0 || (a + b) > 1.0) return INFINITY;
	
        // barycentric coordinates, not currently used 
	//float b1 = 1.0 - a - b;
	//float b2 = a;
	//float b3 = b;
	
	return t;
}
*/

/*
//-----------------------------------------------------------------------
float TriangleIntersect( vec3 v0, vec3 v1, vec3 v2, vec3 normal, Ray r )
//-----------------------------------------------------------------------
{
	vec3 u, v, n;    // triangle vectors
	vec3 w0, w, x;   // ray and intersection vectors
	float rt, a, b;  // params to calc ray-plane intersect
	
	// get triangle edge vectors and plane normal
	u = v2 - v0;
	v = v1 - v0;
	//n = cross(u, v);
	n = -normal; // pre-calculated normal
	    
	w0 = r.origin - v0;
	//w0 = v0 - r.origin;
	a = -dot(n,w0);
	b = dot(n, r.direction);
	if (b < 0.0001)   // ray is parallel to triangle plane
		return INFINITY;
		
	// get intersect point of ray with triangle plane
	rt = a / b;
	if (rt < 0.0)          // ray goes away from triangle
		return INFINITY;   // => no intersect
		
	x = r.origin + rt * r.direction; // intersect point of ray and plane
	
	// is x inside Triangle?
	float uu, uv, vv, wu, wv, D;
	uu = dot(u,u);
	uv = dot(u,v);
	vv = dot(v,v);
	w = x - v0;
	wu = dot(w,u);
	wv = dot(w,v);
	D = 1.0 / (uv * uv - uu * vv);
	
	// get and test parametric coords
	float s, t;
	s = (uv * wv - vv * wu) * D;
	if (s < 0.0 || s > 1.0)       // x is outside T
		return INFINITY;
	t = (uv * wu - uu * wv) * D;
	if (t < 0.0 || (s + t) > 1.0) // x is outside T
		return INFINITY;
		
	return rt;                    // x is in T
}
*/

/*
//----------------------------------------------------------------------------
float QuadIntersect( vec3 v0, vec3 v1, vec3 v2, vec3 v3, vec3 normal, Ray r )
//----------------------------------------------------------------------------
{
	vec3 u, v, n;    // triangle vectors
	vec3 w0, w, x;   // ray and intersection vectors
	float rt, a, b;  // params to calc ray-plane intersect
	
	// get first triangle edge vectors and plane normal
	v = v2 - v0;
	u = v1 - v0; // switched u and v names to save calculation later below
	//n = cross(v, u); // switched u and v names to save calculation later below
	n = -normal; // can avoid cross product if normal is already known
	    
	w0 = r.origin - v0;
	a = -dot(n,w0);
	b = dot(n, r.direction);
	if (b < 0.0001)   // ray is parallel to quad plane
		return INFINITY;
		
	// get intersect point of ray with quad plane
	rt = a / b;
	if (rt < 0.0)          // ray goes away from quad
		return INFINITY;   // => no intersect
	    
	x = r.origin + rt * r.direction; // intersect point of ray and plane
	
	// is x inside first Triangle?
	float uu, uv, vv, wu, wv, D;
	uu = dot(u,u);
	uv = dot(u,v);
	vv = dot(v,v);
	w = x - v0;
	wu = dot(w,u);
	wv = dot(w,v);
	D = 1.0 / (uv * uv - uu * vv);
	
	// get and test parametric coords
	float s, t;
	s = (uv * wv - vv * wu) * D;
	if (s >= 0.0 && s <= 1.0)
	{
		t = (uv * wu - uu * wv) * D;
		if (t >= 0.0 && (s + t) <= 1.0)
		{
			return rt;
		}
	}
	
	// is x inside second Triangle?
	u = v3 - v0;
	///v = v2 - v0;  //optimization - already calculated above
	
	uu = dot(u,u);
	uv = dot(u,v);
	///vv = dot(v,v);//optimization - already calculated above
	///w = x - v0;   //optimization - already calculated above
	wu = dot(w,u);
	///wv = dot(w,v);//optimization - already calculated above
	D = 1.0 / (uv * uv - uu * vv);
	
	// get and test parametric coords
	s = (uv * wv - vv * wu) * D;
	if (s >= 0.0 && s <= 1.0)
	{
		t = (uv * wu - uu * wv) * D;
		if (t >= 0.0 && (s + t) <= 1.0)
		{
			return rt;
		}
	}


	return INFINITY;
}
*/

//----------------------------------------------------------------------------
float BoxIntersect( vec3 minCorner, vec3 maxCorner, Ray r, out vec3 normal )
//----------------------------------------------------------------------------
{
	vec3 invDir = 1.0 / r.direction;
	vec3 tmin = (minCorner - r.origin) * invDir;
	vec3 tmax = (maxCorner - r.origin) * invDir;
	
	vec3 real_min = min(tmin, tmax);
	vec3 real_max = max(tmin, tmax);
	
	float minmax = min( min(real_max.x, real_max.y), real_max.z);
	float maxmin = max( max(real_min.x, real_min.y), real_min.z);
	
	if (minmax > maxmin)
	{
		
		if (maxmin > 0.0) // if we are outside the box
		{
			normal = -sign(r.direction) * step(real_min.yzx, real_min) * step(real_min.zxy, real_min);
			return maxmin;	
		}
		
		else if (minmax > 0.0) // else if we are inside the box
		{
			normal = -sign(r.direction) * step(real_max, real_max.yzx) * step(real_max, real_max.zxy);
			return minmax;
		}
				
	}
	
	return INFINITY;
}


//-----------------------------------------------------------------------
float SceneIntersect( Ray r, inout Intersection intersec )
//-----------------------------------------------------------------------
{
	float d;
	float t = INFINITY;
	vec3 n;
	
        for (int i = 0; i < N_SPHERES; i++)
        {
		d = SphereIntersect( spheres[i].radius, spheres[i].position, r );
		if (d < t)
		{
			t = d;
			intersec.normal = normalize((r.origin + r.direction * t) - spheres[i].position);
			intersec.emission = spheres[i].emission;
			intersec.color = spheres[i].color;
			intersec.type = spheres[i].type;
			intersec.id = SPHERE_ID;
		}
        }
	
	/*
	for (int i = 0; i < N_DISKS; i++)
        {
		d = DiskIntersect( disks[i].radiusSq, disks[i].pos, disks[i].normal, r );
		if (d < t)
		{
			t = d;
			intersec.normal = normalize(disks[i].normal);
			intersec.emission = disks[i].emission;
			intersec.color = disks[i].color;
			intersec.type = disks[i].type;
			intersec.id = DISK_ID;
		}
        }
	
	for (int i = 0; i < N_PLANES; i++)
        {
		d = PlaneIntersect( planes[i].pla, r );
		if (d < t)
		{
			t = d;
			intersec.normal = normalize(planes[i].pla.xyz);
			intersec.emission = planes[i].emission;
			intersec.color = planes[i].color;
			intersec.type = planes[i].type;
			intersec.id = PLANE_ID;
		}
        }
	
	
	for (int i = 0; i < N_TRIANGLES; i++)
        {
		d = TriangleIntersect( triangles[i].v0, triangles[i].v1, triangles[i].v2, triangles[i].normal, r );
		if (d < t)
		{
			t = d;
			intersec.normal = normalize(triangles[i].normal);
			intersec.emission = triangles[i].emission;
			intersec.color = triangles[i].color;
			intersec.type = triangles[i].type;
			intersec.id = TRIANGLE_ID;
		}
        }
	
	
	for (int i = 0; i < N_QUADS; i++)
        {
		d = QuadIntersect( quads[i].v0, quads[i].v1, quads[i].v2, quads[i].v3, quads[i].normal, r );
		if (d < t)
		{
			t = d;
			intersec.normal = normalize(quads[i].normal);
			intersec.emission = quads[i].emission;
			intersec.color = quads[i].color;
			intersec.type = quads[i].type;
			intersec.id = QUAD_ID;
		}
        }
	
	
	for (int i = 0; i < N_BOXES; i++)
        {
	
		d = BoxIntersect( boxes[i].minCorner, boxes[i].maxCorner, r, n );
		if (d < t)
		{
			t = d;
			intersec.normal = normalize(n);
			intersec.emission = boxes[i].emission;
			intersec.color = boxes[i].color;
			intersec.type = boxes[i].type;
			intersec.id = BOX_ID;
		}
        }
	
	*/
	
	for (int i = 0; i < N_ELLIPSOIDS; i++)
        {
		d = EllipsoidIntersect( ellipsoids[i].radii, ellipsoids[i].position, r );
		if (d < t)
		{
			t = d;
			intersec.normal = normalize( ((r.origin + r.direction * t) - ellipsoids[i].position) / (ellipsoids[i].radii * ellipsoids[i].radii) );
			intersec.emission = ellipsoids[i].emission;
			intersec.color = ellipsoids[i].color;
			intersec.type = ellipsoids[i].type;
			intersec.id = ELLIPSOID_ID;
		}
	}
	
	for (int i = 0; i < N_PARABOLOIDS; i++)
        {
		d = ParaboloidIntersect( paraboloids[i].rad, paraboloids[i].height, paraboloids[i].pos, r, n );
		if (d < t)
		{
			t = d;
			intersec.normal = normalize(n);
			intersec.emission = paraboloids[i].emission;
			intersec.color = paraboloids[i].color;
			intersec.type = paraboloids[i].type;
			intersec.id = PARABOLOID_ID;
		}
	}
	
	for (int i = 0; i < N_HYPERBOLICPARABOLOIDS; i++)
        {
		d = HyperbolicParaboloidIntersect( hyperbolicParaboloids[i].rad, hyperbolicParaboloids[i].height, hyperbolicParaboloids[i].pos, r, n );
		if (d < t)
		{
			t = d;
			intersec.normal = normalize(n);
			intersec.emission = hyperbolicParaboloids[i].emission;
			intersec.color = hyperbolicParaboloids[i].color;
			intersec.type = hyperbolicParaboloids[i].type;
			intersec.id = HYPERBOLICPARABOLOID_ID;
		}
	}
	
	for (int i = 0; i < N_HYPERBOLOIDS; i++)
        {
		d = HyperboloidIntersect( hyperboloids[i].rad, hyperboloids[i].height, hyperboloids[i].pos, r, n );
		if (d < t)
		{
			t = d;
			intersec.normal = normalize(n);
			intersec.emission = hyperboloids[i].emission;
			intersec.color = hyperboloids[i].color;
			intersec.type = hyperboloids[i].type;
			intersec.id = HYPERBOLOID_ID;
		}
	}
	
	for (int i = 0; i < N_CYLINDERS; i++)
        {
		d = CylinderIntersect( cylinders[i].position, cylinders[i].position + vec3(0,30,30), cylinders[i].radius, r, n );
		if (d < t)
		{
			t = d;
			intersec.normal = normalize(n);
			intersec.emission = cylinders[i].emission;
			intersec.color = cylinders[i].color;
			intersec.type = cylinders[i].type;
			intersec.id = CYLINDER_ID;
		}
        }
	
	for (int i = 0; i < N_CLOSEDCYLINDERS; i++)
        {
		vec4 res = iCylinder( r.origin, r.direction, closedCylinders[i].cap1pos, 
					closedCylinders[i].cap2pos, closedCylinders[i].radius);
		if (res.x < t && res.x > 0.0)
		{
			t = res.x;
			intersec.normal = normalize(vec3(res.yzw));
			intersec.emission = closedCylinders[i].emission;
			intersec.color = closedCylinders[i].color;
			intersec.type = closedCylinders[i].type;
			intersec.id = CLOSEDCYLINDER_ID;
		}
        }
	
	for (int i = 0; i < N_CONES; i++)
        {
		d = ConeIntersect( cones[i].pos0, cones[i].radius0, cones[i].pos1, cones[i].radius1, r, n );
		if (d < t)
		{
			t = d;
			intersec.normal = normalize(n);
			intersec.emission = cones[i].emission;
			intersec.color = cones[i].color;
			intersec.type = cones[i].type;
			intersec.id = CONE_ID;
		}
        }
	
	for (int i = 0; i < N_CAPSULES; i++)
        {
		d = CapsuleIntersect( capsules[i].pos0, capsules[i].radius0, capsules[i].pos1, capsules[i].radius1, r, n );
		if (d < t)
		{
			t = d;
			intersec.normal = normalize(n);
			intersec.emission = capsules[i].emission;
			intersec.color = capsules[i].color;
			intersec.type = capsules[i].type;
			intersec.id = CAPSULE_ID;
		}
        }
	
	Ray rTrans = r;
	
	for (int i = 0; i < N_TORII; i++)
        {
		rTrans = r;
		rTrans.origin += vec3(60.0,-3.0,-50.0);
		d = TorusIntersect( torii[i].pos, torii[i].radius0, torii[i].radius1, rTrans );
		if (d < t)
		{
			t = d;
			vec3 hit = rTrans.origin + rTrans.direction * t;
			intersec.normal = normalize( hit*(dot(hit,hit)- torii[i].radius1*torii[i].radius1 - torii[i].radius0*torii[i].radius0*vec3(1.0,1.0,-1.0)));
			intersec.emission = torii[i].emission;
			intersec.color = torii[i].color;
			intersec.type = torii[i].type;
			intersec.id = TORUS_ID;
		}
        }
	
	/*
	// DEBUG AABB Bounding Box intersection
	float tBox = BoxIntersect(uMeshBBox_min, uMeshBBox_max, r, n);
	if ( tBox < t )
	{
		t = tBox;	
		intersec.normal = normalize(n);
		intersec.emission = vec3(0);
		intersec.color = vec3(1,0,1);
		intersec.type = DIFF;
		intersec.id = BOX_ID;
	}
	
	
	
	float tBox = BoxIntersect(uMeshBBox_min, uMeshBBox_max, r);
	if ( tBox < t )
	{
		float iX15;
		float InvWidth = 0.00024414062; // (1.0 / 4096 texture width)
		vec3 p0;
		vec3 v0;
		vec3 edge1;
		vec3 edge2;
		vec3 triNormal;
		
		for (int i = 0; i < NUMBER_OF_TRIANGLES; i++)
		{
		
			iX15 = float(i) * 15.0;
			
			v0    = vec3( texture2D(tTriangleTexture, vec2( (iX15 + 0.0) * InvWidth, 0) ).a,
				      texture2D(tTriangleTexture, vec2( (iX15 + 1.0) * InvWidth, 0) ).a,
				      texture2D(tTriangleTexture, vec2( (iX15 + 2.0) * InvWidth, 0) ).a );
				      
			edge1 = vec3( texture2D(tTriangleTexture, vec2( (iX15 + 3.0) * InvWidth, 0) ).a,
				      texture2D(tTriangleTexture, vec2( (iX15 + 4.0) * InvWidth, 0) ).a,
				      texture2D(tTriangleTexture, vec2( (iX15 + 5.0) * InvWidth, 0) ).a );
				      
			edge2 = vec3( texture2D(tTriangleTexture, vec2( (iX15 + 6.0) * InvWidth, 0) ).a,
				      texture2D(tTriangleTexture, vec2( (iX15 + 7.0) * InvWidth, 0) ).a,
				      texture2D(tTriangleTexture, vec2( (iX15 + 8.0) * InvWidth, 0) ).a );
				      
			p0    = vec3( texture2D(tTriangleTexture, vec2( (iX15 + 9.0) * InvWidth, 0) ).a,
				      texture2D(tTriangleTexture, vec2( (iX15 + 10.0) * InvWidth, 0) ).a,
				      texture2D(tTriangleTexture, vec2( (iX15 + 11.0) * InvWidth, 0) ).a );
			
			triNormal = vec3( texture2D(tTriangleTexture, vec2( (iX15 + 12.0) * InvWidth, 0) ).a,
				          texture2D(tTriangleTexture, vec2( (iX15 + 13.0) * InvWidth, 0) ).a,
				          texture2D(tTriangleTexture, vec2( (iX15 + 14.0) * InvWidth, 0) ).a );
					  
			d = ArenbergTriangleIntersect( p0, v0, edge1, edge2, r );
			
			if (d < t)
			{
				t = d;
				//intersec.normal = getTriangleNormal( i );
				intersec.normal = triNormal;
				intersec.emission = vec3(0);
				intersec.color = vec3(1,0,0);
				intersec.type = REFR;
				intersec.id = OBJ_TRIANGLE_ID;
			}
		} // end for (int i = 0; i < NUMBER_OF_TRIANGLES; i++)
	
	} // end if (tBox < t )
	*/
	
	return t;
	
} // end float SceneIntersect( Ray r, inout Intersection intersec )

vec3 randomSphereDirection()
{
	vec2 r = vec2(rand(),rand())*TWO_PI;
	return vec3(sin(r.x)*vec2(sin(r.y),cos(r.y)),cos(r.x));	
}
/*
vec3 randomHemisphereDirection( const vec3 n )
{
	vec2 r = vec2(rand(),rand())*TWO_PI;
	vec3 dr = vec3(sin(r.x)*vec2(sin(r.y),cos(r.y)),cos(r.x));	
	return dot(dr,n) * dr;
}

vec3 randomDirectionInSphere()
{
	float up = rand() * 2.0 - 1.0; // cos(theta)
	float over = sqrt(1.0 - up * up); // sin(theta)
	float around = rand() * TWO_PI;

	return vec3( up, cos(around) * over, sin(around) * over );
}
*/
vec3 randomCosWeightedDirectionInHemisphere(vec3 nl)
{
	float up = sqrt(rand()); // weighted cos(theta)
	float over = sqrt(1.0 - up * up); // sin(theta)
	float around = rand() * TWO_PI;
	vec3 u = normalize( cross( abs(nl.x) > 0.1 ? vec3(0, 1, 0) : vec3(1, 0, 0), nl ) );
	vec3 v = normalize( cross(nl, u) );
	return vec3( cos(around) * over * u ) + ( sin(around) * over * v ) + (up * nl);		
}

vec3 calcDirectLighting(vec3 mask, vec3 x, vec3 nl, Sphere light)
{
	vec3 dirLight = vec3(0.0);
	Intersection shadowIntersec;
	
	// cast shadow ray from intersection point
	vec3 ld = light.position + (normalize(randomSphereDirection()) * (light.radius*0.8));
	vec3 srDir = normalize(ld - x);
	float srDotNl = max(0.001, dot(srDir, nl));
	//if( srDotNl < 0.01 )
	//	return dirLight;
		
	Ray shadowRay = Ray(x, srDir);
	shadowRay.origin += nl;
	float st = SceneIntersect(shadowRay, shadowIntersec);
	if ( shadowIntersec.type == LIGHT )
	{
		float r2 = light.radius * light.radius;
		vec3 d = light.position - shadowRay.origin;
		float d2 = dot(d,d);
		float cos_a_max = sqrt(1. - clamp( r2 / d2, 0., 1.));
		float weight = 2. * (1. - cos_a_max);
		dirLight = mask * light.emission * weight * srDotNl;
	}
	
	return dirLight;
}


//-----------------------------------------------------------------------
vec3 CalculateRadiance( Ray r )
//-----------------------------------------------------------------------
{
	vec3 accumCol = vec3(0.0);
        vec3 mask = vec3(1.0);
	vec3 checkCol0 = vec3(1);
	vec3 checkCol1 = vec3(0.5);
        Intersection intersec;
	bool bounceIsSpecular = true;
	int sampleDiffuseBudget = 2;
	Sphere lightChoice;
	
	float randChoose = rand();
	if (randChoose < 0.33)
		lightChoice = spheres[0];
	else if (randChoose < 0.66)
		lightChoice = spheres[1];
	else lightChoice = spheres[2];
	
	for (int depth = 0; depth < 5; depth++)
	{
		
		float t = SceneIntersect(r, intersec);
		/*
		//not used in this scene because we are inside a huge sphere - no rays can escape
		if (t == INFINITY)
		{
			break;
		}
		*/
		
		// if we reached something bright, don't spawn any more rays
		if (intersec.type == LIGHT)
		{
			if (bounceIsSpecular)
			{
				accumCol = mask * intersec.emission;
			}
			
			break;
		}
		
		
		// useful data 
		vec3 n = intersec.normal;
		vec3 nl = dot(n,r.direction) < 0.0 ? normalize(n) : normalize(n * -1.0);
		vec3 x = r.origin + r.direction * t;
		
		
		if (intersec.type == DIFF || intersec.type == CHECK) // Ideal DIFFUSE reflection
		{
			if( intersec.type == CHECK )
			{
				float q = clamp( mod( dot( floor(x.xz * 0.04), vec2(1.0) ), 2.0 ) , 0.0, 1.0 );
				intersec.color = checkCol0 * q + checkCol1 * (1.0 - q);	
			}
			
			mask *= intersec.color;
			
			accumCol += calcDirectLighting(mask, x, nl, lightChoice);
			
			// Russian Roulette
			/*
			if (rand() > 0.5)
				break;
			else mask *= 2.0;
			*/
			sampleDiffuseBudget -= 1;
			if (sampleDiffuseBudget < 0) break;
			
			// choose random Diffuse sample vector
			vec3 d = randomCosWeightedDirectionInHemisphere( nl );
			//vec3 d = randomHemisphereDirection(nl);
			r = Ray( x, normalize(d) );
			r.origin += r.direction;
			mask *= max(0.01, dot(r.direction, nl));
			bounceIsSpecular = false;
			continue;
		}
		
		if (intersec.type == SPEC)  // Ideal SPECULAR reflection
		{
			mask *= intersec.color;
			
			r = Ray( x, reflect(r.direction, nl) );
			r.origin += nl;
			bounceIsSpecular = true;
			continue;
		}
		
		if (intersec.type == REFR)  // Ideal dielectric REFRACTION
		{
			bool into = dot(n,nl) > 0.0;  // Ray from outside going in?
			float nc = 1.0; // IOR of air
			float nt = 1.33; // IOR of water
			if ( !into ) 
			{
				nc = 1.33;
				nt = 1.0;
			}
			
			float nnt = nc / nt;
			vec3 tdir = refract(r.direction, nl, nnt);
				
			// Original Fresnel equations
			float cosThetaInc = dot(nl, r.direction);
			float cosThetaTra = dot(nl, tdir);
			float coefS = (nc * cosThetaInc - nt * cosThetaTra) / (nc * cosThetaInc + nt * cosThetaTra);
			float coefP = (nc * cosThetaTra - nt * cosThetaInc) / (nc * cosThetaTra + nt * cosThetaInc);
			float Re = ( (coefS * coefS) + (coefP * coefP) ) * 0.5; // Unpolarized
			//float Tr = 1.0 - Re;
		
			float transmissionProbability = rand();
			
			if( transmissionProbability > Re ) // transmit ray through surface
			{
				mask *= intersec.color;
				r = Ray(x, normalize(tdir));
				r.origin -= nl * 2.0;
				bounceIsSpecular = true;
				continue;
			}
			else // reflect ray from surface
			{
				r = Ray( x, reflect(r.direction, nl) );
			    	r.origin += nl * 2.0;
				bounceIsSpecular = true;
			    	continue;	
			}
		}
		
		if (intersec.type == COAT)  // Diffuse object underneath with ClearCoat on top (like car, or shiny pool ball)
		{
			
			// Schlick Fresnel approx.
			float ddn = dot(-r.direction, nl);
			float nc = 1.0; // IOR of air
			float nt = 1.5; // IOR of ClearCoat 
			float R0 = (nc - nt) / (nc + nt);
			R0 *= R0;
			float c = 1.0 - ddn;
			float Re = R0 + (1.0 - R0) * c * c * c * c * c;
			
			float shininess = 1.0;
			
			// choose random sample vector for diffuse material underneath ClearCoat
			vec3 d = randomCosWeightedDirectionInHemisphere( nl );
			
			// choose either specular reflection or diffuse
			if( rand() < Re )
			{	
				r = Ray( x, mix( normalize(d), reflect(r.direction, nl), shininess ) );
				r.origin += nl;
				bounceIsSpecular = true;
				continue;	
			}
			else
			{
				mask *= intersec.color;
				
				accumCol += calcDirectLighting(mask, x, nl, lightChoice);
				
				r = Ray( x, normalize(d) );
				r.origin += r.direction;
				//mask *= max(0.01, dot(r.direction, nl));
				bounceIsSpecular = false;
				continue;
			}
			
		} //end if (intersec.type == COAT)
		/*
		if (intersec.type == TRANSLUCENT)  // Translucent Sub-Surface Scattering material
		{
			float translucentDensity = 0.3;//0.02
			float scatteringDistance = -log( rand() ) / translucentDensity;
			if (scatteringDistance > t) 
			{
				//sampleDiffuseBudget -= 1;
				//if (sampleDiffuseBudget < 0) break;
			
				mask *= computeTransmission(vec3(1.0, 0.1, 0.0), t);
				
				accumCol += calcDirectLighting(mask, x, nl, lightChoice);
				
				x = x + r.direction * scatteringDistance;
				r = Ray( x, r.direction ); //transmission
				r.origin += r.direction;
				//bounceIsSpecular = false; // so lights can be seen through thin material
				continue;
			}
			else
			{
				//sampleDiffuseBudget -= 1;
				//if (sampleDiffuseBudget < 0) break;
				
				// Compute how much light was absorbed along the ray before it was scattered:
				mask *= computeTransmission(vec3(1.0, 0.1, 0.0), scatteringDistance);
				
				accumCol += calcDirectLighting(mask, x, nl, lightChoice);
				
				// Scatter the ray:
				x = x + r.direction * scatteringDistance;
				//vec3 d = randomSphereDirection(); // Isotropic scattering
				vec3 d = randomCosWeightedDirectionInHemisphere( nl ); // weighted scattering (reflects light better)
				r = Ray( x, normalize(d) );
				r.origin += r.direction;
				bounceIsSpecular = false;
				continue;
			}	
			
		} // end if (intersec.type == TRANSLUCENT)
		
		if (intersec.type == VOLUME)  // Volume filled with participating medium (i.e. smoke, fog, dust, etc.)
		{
		
			float density = 0.5;
			if (rand() > density)
			{
				// transmission
				r = Ray( x, r.direction );
				r.origin += r.direction;
				//bounceIsSpecular = false; // so lights can be seen through haze
				continue;
			}
			else
			{
				//sampleDiffuseBudget -= 1;
				//if (sampleDiffuseBudget < 0) break;
			
				mask *= intersec.color;
				
				accumCol += calcDirectLighting(mask, x, nl, lightChoice);
				
				// scattering
				// choose cosWeighted random Diffuse reflection vector for participating medium
				//vec3 d = randomSphereDirection(); // true isotropic scattering
				vec3 d = randomCosWeightedDirectionInHemisphere( nl ); // weighted scattering (reflects light better)
				r = Ray( x, normalize(d) );
				r.origin += r.direction;
				bounceIsSpecular = false;
				continue;
			}
				
		} // end if (intersec.type == VOLUME)
		
		if (intersec.type == SPECSUB)  // Shiny(specular) coating over Sub-Surface Scattering material
		{
			// Schlick Fresnel approx.
			float ddn = dot(-r.direction, nl);
			float nc = 1.0; // IOR of air
			float nt = 1.3; // IOR of coating (for polished jade)
			float R0 = (nc - nt) / (nc + nt);
			R0 *= R0;
			float c = 1.0 - ddn;
			float Re = R0 + (1.0 - R0) * c * c * c * c * c;
			
			// choose either specular reflection or translucent subsurface scattering/transmission
			if( rand() < Re )
			{
				r = Ray( x, reflect(r.direction, nl) );
				r.origin += nl;
				bounceIsSpecular = true;
				continue;
			}
			
			vec3 transColorCoefficient = vec3(0.2, 0.0, 0.1);
			float translucentDensity = 0.1;
			float scatteringDistance = -log(rand()) / translucentDensity;
			
			if (scatteringDistance < t) 
			{
				// Compute how much light was absorbed along the ray before it was scattered:
				mask *= computeTransmission(transColorCoefficient, scatteringDistance);
			}
			else
			{
				mask *= computeTransmission(transColorCoefficient, t); // transmission
			}
			
			accumCol += calcDirectLighting(mask, x, nl, lightChoice);
			
			x = x + r.direction * scatteringDistance;
			//vec3 d = randomSphereDirection(); // true Isotropic scattering
			vec3 d = randomCosWeightedDirectionInHemisphere( nl );
			r = Ray( x, normalize(d) );
			r.origin += r.direction;
			//mask *= max(0.01, dot(r.direction, nl));
			bounceIsSpecular = false;
			continue;
				
		} // end if (intersec.type == SPECSUB)
		*/
		
	} // end for (int depth = 0; depth < 5; depth++)
	
	return accumCol;      
}

//-----------------------------------------------------------------------
void SetupScene(void)
//-----------------------------------------------------------------------
{
	vec3 z  = vec3(0.0);          
	vec3 L1 = vec3(1.0, 1.0, 1.0) * 10.0;// White light
	vec3 L2 = vec3(1.0, 0.8, 0.2) * 10.0;// Yellow light
	vec3 L3 = vec3(0.1, 0.7, 1.0) * 10.0;// Blue light
		
        spheres[0] = Sphere(150.0, vec3(-400.0, 900.0, 200.0), L1, z, LIGHT);//spherical white Light1 
	spheres[1] = Sphere(100.0, vec3(300.0, 400.0, -300.0), L2, z, LIGHT);//spherical yellow Light2
	spheres[2] = Sphere( 50.0, vec3(500.0, 250.0, -100.0), L3, z, LIGHT);//spherical blue Light3
	
	spheres[3] = Sphere(1000.0, vec3(  0.0, 1000.0,  0.0), z, vec3(1.0, 1.0, 1.0),       CHECK);//Checkered Floor Huge Sphere       
        spheres[4] = Sphere(  15.0, vec3( 32.0,   16.0, 30.0), z, vec3(1.0, 1.0, 1.0),        REFR);//Glass sphere
	
	ellipsoids[0] = Ellipsoid(  vec3(30,40,16), vec3(90,5,-30), z, vec3(1.0, 0.765557, 0.336057), SPEC);//metallic gold ellipsoid
	ellipsoids[1] = Ellipsoid(  vec3(6,18,20), vec3(-25,18.5,5), z, vec3(1.0, 1.0, 1.0), SPEC);//Mirror ellipsoid
	
	paraboloids[0] = Paraboloid( 20.0, 15.0, vec3(20,2,-50), z, vec3(1.0, 0.2, 0.7), REFR);//paraboloid
	
	hyperbolicParaboloids[0] = HyperbolicParaboloid( 40.0, 40.0, vec3(20,70,-50), z, vec3(1.0, 0.2, 0.7), CHECK);//hyperbolic paraboloid
	
	//hyperboloids[0] = Hyperboloid( 4.0, 15.0, vec3(-15,22,-100), z, vec3(0.0, 0.2, 0.4), SPEC);//hyperboloid
	hyperboloids[0] = Hyperboloid( 4.0, 15.0, vec3(-15,22,-100), z, vec3(0.3, 0.7, 0.5), REFR);//hyperboloid
	
	cylinders[0] = Cylinder( 15.0, 30.0, vec3(-70,7,-80), z, vec3(0.7,0.01,0.01), REFR);//red glass Cylinder
	closedCylinders[0] = ClosedCylinder( 14.0, vec3(-60,0,20), vec3(-60,14,20), z, vec3(0.05,0.05,0.05), COAT);//dark gray ClosedCylinder
	
	cones[0] = Cone( vec3(1,20,-12), 15.0, vec3(1,0,-12), 0.0, z, vec3(0.01,0.1,0.5), REFR);//blue Cone
	
	capsules[0] = Capsule( vec3(80,13,15), 10.0, vec3(110,15.8,15), 10.0, z, vec3(1.0,1.0,1.0), COAT);//white Capsule
	
	torii[0] = Torus( vec3(0,0,0), 10.0, 1.5, z, vec3(0.955008, 0.637427, 0.538163), SPEC);//copper Torus
	
	/*
	boxes[0] = Box( vec3(0.0,11.0,-40.0), vec3(50.0,18.0,-110.0), z, vec3(0.2,0.9,0.7), REFR);//Glass Box
	boxes[1] = Box( vec3(6.0,13.0,-46.0), vec3(44.0,16.0,-104.0), z, vec3(0.0,0.0,0.0), DIFF);//Diffuse Box
	
	planes[0] = Plane( vec4( -1.0,-0.1,0.0,800.0), z, vec3(0.9,0.9,0.9), DIFF);//WhitePlane Right Wall
	planes[1] = Plane( vec4(  1.0,-0.1,0.0,800.0), z, vec3(0.9,0.0,0.9), DIFF);//MagentaPlane Left Wall
	planes[2] = Plane( vec4(  0.0,-0.1,1.0,800.0), z, vec3(0.9,0.9,0.9), DIFF);//WhitePlane Back Wall
	planes[3] = Plane( vec4( 0.0,-0.1,-1.0,800.0), z, vec3(0.0,0.9,0.9), DIFF);//CyanPlane Front Wall
	
	quads[0] = Quad( vec3(0.0,0.0,1.0), vec3( -150.0,40.0,-50.0), vec3( -100.0,40.0,-50.0), vec3( -100.0,90.0,-50.0 ), vec3( -150.0,90.0,-50.0 ), z, vec3(0.0,0.0,0.9), DIFF);//Blue Quad
	
	disks[0] = Disk( 190.0, vec3(-100.0,18.0,-10.0), vec3( 1.0,-1.0,0.0 ), z, vec3(0.9,0.01,0.01), DIFF);//RedDisk Left
	disks[1] = Disk( 16.5 * 16.5, vec3( 30.0,-10.0,-180.0), vec3( -1.0,0.0,0.3 ), L3, z, LIGHT);//DiskLight 
	
	triangles[0] = Triangle( vec3(0.0,0.0,1.0), vec3( 0.0,30.0,-50.0), vec3( 20.0,60.0,-50.0), vec3( -20.0,60.0,-50.0 ), z, vec3(0.0,0.9,0.0), DIFF);//Green Triangle
	*/
	
}



void main( void )
{

	vec3 camPos     = vec3( uCameraMatrix[3][0],  uCameraMatrix[3][1],  uCameraMatrix[3][2]);
	vec3 camRight   = vec3( uCameraMatrix[0][0],  uCameraMatrix[0][1],  uCameraMatrix[0][2]);
	vec3 camUp      = vec3( uCameraMatrix[1][0],  uCameraMatrix[1][1],  uCameraMatrix[1][2]);
	vec3 camForward = vec3(-uCameraMatrix[2][0], -uCameraMatrix[2][1], -uCameraMatrix[2][2]);
	
	// seed for rand() function
	seed = mod(uSampleCounter,1000.0) * uRandomVector.x - uRandomVector.y + uResolution.y * gl_FragCoord.x / uResolution.x + uResolution.x * gl_FragCoord.y / uResolution.y;
	
	float r1 = 2.0 * rand();
	float r2 = 2.0 * rand();
	
	vec2 d = vec2(0.0);
	if ( !uCameraIsMoving ) 
	{
		d.x = r1 < 1.0 ? sqrt(r1) - 1.0 : 1.0 - sqrt(2.0 - r1);
		d.y = r2 < 1.0 ? sqrt(r2) - 1.0 : 1.0 - sqrt(2.0 - r2);
	}
	
	d *= (1.0 / (uResolution * 0.5));
	d += 2.0 * vUv - 1.0;
	
	vec3 rayDir = normalize( d.x * camRight * uULen + d.y * camUp * uVLen + camForward );
	
	// depth of field
	vec3 focalPoint = uFocusDistance * rayDir;
	float randomAngle = rand() * TWO_PI; // pick random point on aperture
	float randomRadius = rand() * uApertureSize;
	vec3  randomAperturePos = ( cos(randomAngle) * camRight + sin(randomAngle) * camUp ) * randomRadius;
	// point on aperture to focal point
	vec3 finalRayDir = normalize(focalPoint - randomAperturePos);
	
	Ray ray = Ray( camPos + randomAperturePos , finalRayDir );
	
	SetupScene();
	
	// perform path tracing and get resulting pixel color
	vec3 pixelColor = CalculateRadiance( ray );
	
	vec3 previousColor = texture2D(tPreviousTexture, vUv).rgb;
	
	if ( uCameraJustStartedMoving )
	{
		previousColor = vec3(0.0); // clear rendering accumulation buffer
		pixelColor *= 1.2;
	}
	else if ( uCameraIsMoving )
	{
		previousColor *= 0.5; // motion-blur trail amount (old image)
		pixelColor *= (uSampleCounter) * 0.5; // brightness of new image (noisy)
	}
		
	gl_FragColor = vec4( pixelColor + previousColor, 1.0 );
	
}

		</script>
		
		
		<script>
			
			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
			
			var SCREEN_WIDTH = window.innerWidth;
			var SCREEN_HEIGHT = window.innerHeight;
			var container, stats;
			var controls;
			var pathTracingScene, screenTextureScene, screenOutputScene;
			var pathTracingUniforms, screenTextureUniforms, screenOutputUniforms;
			var pathTracingDefines;
			var pathTracingGeometry, pathTracingMaterial, pathTracingMesh;
			var screenTextureGeometry, screenTextureMaterial, screenTextureMesh;
			var screenOutputGeometry, screenOutputMaterial, screenOutputMesh;
			var pathTracingRenderTarget, screenOutputRenderTarget;
			var quadCamera, worldCamera;
			var renderer, clock;
			var frameTime, elapsedTime;
			var fovScale;
			var increaseFOV = false;
			var decreaseFOV = false;
			var apertureSize = 0.0;
			var increaseAperture = false;
			var decreaseAperture = false;
			var focusDistance = 132.0;
			var increaseFocusDist = false;
			var decreaseFocusDist = false;
			var pixelRatio = window.devicePixelRatio * 0.5;
			var TWO_PI = Math.PI * 2;
			var randomVector = new THREE.Vector3();
			var sampleCounter = 1.0;
			var keyboard = new THREEx.KeyboardState();
			var cameraIsMoving = false;
			var cameraJustStartedMoving = false;
			var cameraRecentlyMoving = false;
			var isPaused = true;
			var oldYawRotation, oldPitchRotation;
			var mobileJoystickControls = null;
			var oldDeltaX = 0, oldDeltaY = 0;
			var newDeltaX = 0, newDeltaY = 0;
			var mobileControlsMoveX = 0;
			var mobileControlsMoveY = 0;
			var stillFlagX = true, stillFlagY = true;
			var oldPinchWidthX = 0;
			var oldPinchWidthY = 0;
			var pinchDeltaX = 0;
			var pinchDeltaY = 0;
			var camFlightSpeed = 60;
			var fontAspect;
			/*
			var objMeshes = {};
			var total_number_of_triangles = 0;
			var triangle_array;
			var triangleDataTexture;
			var v0 = new THREE.Vector3();
			var v1 = new THREE.Vector3();
			var v2 = new THREE.Vector3();
			var scene_aabbox_min = new THREE.Vector3();
			var scene_aabbox_max = new THREE.Vector3();
			*/
			
			// the following variables will be used to calculate rotations and directions from the camera
			var cameraDirectionVector = new THREE.Vector3();//for moving where the camera is looking
			var cameraRightVector = new THREE.Vector3();//for strafing the camera right and left
			var cameraUpVector = new THREE.Vector3();//for moving camera up and down
			var cameraWorldQuaternion = new THREE.Quaternion();//for rotating scene objects to match camera's current rotation
			var cameraControlsObject;//for positioning and moving the camera itself
			var cameraControlsYawObject;//allows access to control camera's left/right movements through mobile input
			var cameraControlsPitchObject;//allows access to control camera's up/down movements through mobile input

			var PI_2 = Math.PI / 2;//used by controls below
			
			var infoElement = document.getElementById( 'info' );
			infoElement.style.cursor = "default";
			infoElement.style.webkitUserSelect = "none";
			infoElement.style.MozUserSelect = "none";
			
			var cameraInfoElement = document.getElementById( 'cameraInfo' );
			cameraInfoElement.style.cursor = "default";
			cameraInfoElement.style.webkitUserSelect = "none";
			cameraInfoElement.style.MozUserSelect = "none";
			
			var mouseControl = true;
			
			if ( 'createTouch' in document ) {
				mouseControl = false;
				pixelRatio = window.devicePixelRatio * 0.15;
				
				mobileJoystickControls = new MobileJoystickControls ({
					//showJoystick: true,
					enableMultiTouch: true
				});	
			}
			
			// if on mobile device, unpause the app because there is no ESC key and no mouse capture to do
			if ( !mouseControl )
			{
				isPaused = false;
			}
				
			
			if (mouseControl) {

				window.addEventListener( 'wheel', onMouseWheel, false );
				
				document.body.addEventListener("click", function() {
					this.requestPointerLock = this.requestPointerLock || this.mozRequestPointerLock;
					this.requestPointerLock();
				}, false);

				window.addEventListener("click", function(event) {
					event.preventDefault();	
				}, false);
				window.addEventListener("dblclick", function(event) {
					event.preventDefault();	
				}, false);


				var pointerlockChange = function ( event ) {

					if ( document.pointerLockElement === document.body || 
					    document.mozPointerLockElement === document.body || document.webkitPointerLockElement === document.body ) {

						isPaused = false;

					} else {

						isPaused = true;

					}

				};

				// Hook pointer lock state change events
				document.addEventListener( 'pointerlockchange', pointerlockChange, false );
				document.addEventListener( 'mozpointerlockchange', pointerlockChange, false );
				document.addEventListener( 'webkitpointerlockchange', pointerlockChange, false );

			}
			
			function onMouseWheel( event ) {

				event.preventDefault();
				event.stopPropagation();

				if ( event.deltaY > 0 ) {
					
					increaseFOV = true;
				
				} else if ( event.deltaY < 0 ) {
					
					decreaseFOV = true;
					
				}

			}
			
			
			init();					
		     // function init( meshes ) {
			function init() {
				
				renderer = new THREE.WebGLRenderer();
				renderer.autoClear = false;
				// 1 is full resolution, 0.5 is half, 0.25 is quarter, etc. (must be > than 0.0)
				renderer.setPixelRatio(pixelRatio);
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.context.getExtension('OES_texture_float');
				
				container = document.getElementById( 'container' );
				container.appendChild( renderer.domElement );
		      
				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				stats.domElement.style.cursor = "default";
				stats.domElement.style.webkitUserSelect = "none";
				stats.domElement.style.MozUserSelect = "none";
				container.appendChild( stats.domElement );
				
				window.addEventListener( 'resize', onWindowResize, false );
				
				clock = new THREE.Clock();
				
				pathTracingScene = new THREE.Scene();
				screenTextureScene = new THREE.Scene();
				screenOutputScene = new THREE.Scene();
				
				// quadCamera is simply the camera to help render the full screen quad (2 triangles),
				// hence the name.  It is an Orthographic camera that sits facing the view plane, which serves as
				// the window into our 3d world. This camera will not move or rotate for the duration of the app.
				quadCamera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );
				screenTextureScene.add(quadCamera);
				screenOutputScene.add(quadCamera);
				
				// worldCamera is the dynamic camera 3d object that will be positioned, oriented and 
				// constantly updated inside the 3d scene.  Its view will ultimately get passed back to the 
				// stationary quadCamera, which renders the scene to a fullscreen quad (made up of 2 large triangles).
				worldCamera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 1, 1000);
				pathTracingScene.add(worldCamera);
				
				controls = new FirstPersonCameraControls( worldCamera );
							
				cameraControlsObject = controls.getObject();
				cameraControlsYawObject = controls.getYawObject();
				cameraControlsPitchObject = controls.getPitchObject();
				
				pathTracingScene.add( cameraControlsObject );
				
				// for flyCam
				cameraControlsObject.position.set(0,20,120);
				///cameraControlsYawObject.rotation.y = 0.0;
				// look slightly downward
				///cameraControlsPitchObject.rotation.x = -0.4;
				
				oldYawRotation = cameraControlsYawObject.rotation.y;
				oldPitchRotation = cameraControlsPitchObject.rotation.x;
				
				// now that we moved and rotated the camera, the following line force-updates the camera's matrix,
				//  and prevents rendering the very first frame in the old default camera position/orientation
				cameraControlsObject.updateMatrixWorld(true);
				
				pathTracingRenderTarget = new THREE.WebGLRenderTarget( (window.innerWidth * pixelRatio), (window.innerHeight * pixelRatio), {
					minFilter: THREE.NearestFilter,
					magFilter: THREE.NearestFilter,
					format: THREE.RGBAFormat,
					type: THREE.FloatType,
					depthBuffer: false,
					stencilBuffer: false
				} );
				pathTracingRenderTarget.texture.generateMipmaps = false;
				
				screenTextureRenderTarget = new THREE.WebGLRenderTarget( (window.innerWidth * pixelRatio), (window.innerHeight * pixelRatio), {
					minFilter: THREE.NearestFilter, 
					magFilter: THREE.NearestFilter,
					format: THREE.RGBAFormat,
					type: THREE.FloatType,
					depthBuffer: false,
					stencilBuffer: false
				} );
				screenTextureRenderTarget.texture.generateMipmaps = false;
			
			
				pathTracingGeometry = new THREE.PlaneBufferGeometry( 2, 2 );
				
				pathTracingUniforms = {
					
					tPreviousTexture: { type: "t", value: screenTextureRenderTarget.texture },
					//tTriangleTexture: { type: "t", value: triangleDataTexture },
					
					uCameraIsMoving: { type: "b1", value: false },
					uCameraJustStartedMoving: { type: "b1", value: false },
					uTime: { type: "f", value: 0.0 },
					uSampleCounter: { type: "f", value: 0.0 },
					uULen: { type: "f", value: 1.0 },
					uVLen: { type: "f", value: 1.0 },
					uApertureSize: { type: "f", value: 0.0 },
					uFocusDistance: { type: "f", value: 100.0 },
					
					uResolution: { type: "v2", value: new THREE.Vector2() },
					
					//uMeshBBox_min: { type: "v3", value: objMeshes.my_mesh.bounding_box_min },
					//uMeshBBox_max: { type: "v3", value: objMeshes.my_mesh.bounding_box_max },
					uRandomVector: { type: "v3", value: new THREE.Vector3() },
				
					uCameraMatrix: { type: "m4", value: new THREE.Matrix4() }
					
				};
				
				/*
				pathTracingDefines = {
					NUMBER_OF_TRIANGLES: total_number_of_triangles
				};
				*/
			
				pathTracingMaterial = new THREE.ShaderMaterial( {
					uniforms: pathTracingUniforms,
					//defines: pathTracingDefines,
					vertexShader: document.getElementById( 'pathTracingVertexShader' ).textContent,
					fragmentShader: document.getElementById( 'pathTracingFragmentShader' ).textContent,
				        depthTest: false,
					depthWrite: false
				} );
				
				pathTracingMesh = new THREE.Mesh( pathTracingGeometry, pathTracingMaterial );
				pathTracingScene.add( pathTracingMesh );
				
				
				
				// the following keeps the large scene ShaderMaterial quad right in front 
				//   of the camera at all times. This is necessary because without it, the scene 
				//   quad will fall out of view and get clipped when the camera rotates past 180 degrees.
				worldCamera.add( pathTracingMesh );
				
				
				
				screenTextureGeometry = new THREE.PlaneBufferGeometry( 2, 2 );
				
				screenTextureUniforms = {
					tTexture0: { type: "t", value: pathTracingRenderTarget.texture }
				}
				
				screenTextureMaterial = new THREE.ShaderMaterial( {
					uniforms: screenTextureUniforms,
					vertexShader: document.getElementById( 'screenTextureVertexShader' ).textContent,
					fragmentShader: document.getElementById( 'screenTextureFragmentShader' ).textContent,
					depthWrite: false,
					depthTest: false
				} );
				
				screenTextureMesh = new THREE.Mesh(screenTextureGeometry, screenTextureMaterial);
				screenTextureScene.add(screenTextureMesh);
				
				
				
				screenOutputGeometry = new THREE.PlaneBufferGeometry( 2, 2 );
				
				screenOutputUniforms = {
					uOneOverSampleCounter: { type: "f", value: 0.0 },
					tTexture0: { type: "t", value: pathTracingRenderTarget.texture }
				}
				
				screenOutputMaterial = new THREE.ShaderMaterial( {
					uniforms: screenOutputUniforms,
					vertexShader: document.getElementById( 'screenOutputVertexShader' ).textContent,
					fragmentShader: document.getElementById( 'screenOutputFragmentShader' ).textContent,
					depthWrite: false,
					depthTest: false
				} );
				
				screenOutputMesh = new THREE.Mesh(screenOutputGeometry, screenOutputMaterial);
				screenOutputScene.add(screenOutputMesh);
				
				/*
				// Fullscreen API
				document.addEventListener("click", function() {
					
					if ( !document.fullscreenElement && !document.mozFullScreenElement && !document.webkitFullscreenElement ) {

						if (document.documentElement.requestFullscreen) {
							document.documentElement.requestFullscreen();
							
						} else if (document.documentElement.mozRequestFullScreen) {
							document.documentElement.mozRequestFullScreen();
						
						} else if (document.documentElement.webkitRequestFullscreen) {
							document.documentElement.webkitRequestFullscreen();
						
						}

					}
				});
				*/
				
				// onWindowResize() must be at the end of the init() function
				onWindowResize();
				
				// everything is set up, now we can start animating
				animate();
				
			} // end function init()
			
			
			
			function onWindowResize( event ) {
				
				SCREEN_WIDTH = window.innerWidth;
				SCREEN_HEIGHT = window.innerHeight;
				
				renderer.setPixelRatio(pixelRatio);
				renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
				
				fontAspect = (SCREEN_WIDTH / 175) * (SCREEN_HEIGHT / 200);
				if (fontAspect > 25) fontAspect = 25;
				if (fontAspect < 4) fontAspect = 4;
				fontAspect *= 2;
				
				pathTracingUniforms.uResolution.value.x = SCREEN_WIDTH * pixelRatio;
				pathTracingUniforms.uResolution.value.y = SCREEN_HEIGHT * pixelRatio;
				
				pathTracingRenderTarget.setSize( SCREEN_WIDTH * pixelRatio, SCREEN_HEIGHT * pixelRatio );
				screenTextureRenderTarget.setSize( SCREEN_WIDTH * pixelRatio, SCREEN_HEIGHT * pixelRatio );
				
				worldCamera.aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
				worldCamera.updateProjectionMatrix();
				
				// the following scales all scene objects by the worldCamera's field of view,
				// taking into account the screen aspect ratio and multiplying the uniform uULen,
				// the x-coordinate, by this ratio
				fovScale = worldCamera.fov * 0.5 * (Math.PI / 180.0);
				pathTracingUniforms.uVLen.value = Math.tan(fovScale);
				pathTracingUniforms.uULen.value = pathTracingUniforms.uVLen.value * worldCamera.aspect;
				
				if ( !mouseControl ) {
					
					button1Element.style.display = "";
					button2Element.style.display = "";
					button3Element.style.display = "";
					button4Element.style.display = "";
					button5Element.style.display = "";
					button6Element.style.display = "";
					// check if mobile device is in portrait or landscape mode and position buttons accordingly
					if (SCREEN_WIDTH < SCREEN_HEIGHT) {
						
						button1Element.style.right = 36 + "%";
						button2Element.style.right = 2 + "%";
						button3Element.style.right = 16 + "%";
						button4Element.style.right = 16 + "%";
						button5Element.style.right = 3 + "%";
						button6Element.style.right = 3 + "%";

						button1Element.style.bottom = 5 + "%";
						button2Element.style.bottom = 5 + "%";
						button3Element.style.bottom = 13 + "%";
						button4Element.style.bottom = 2 + "%";
						button5Element.style.bottom = 25 + "%";
						button6Element.style.bottom = 18 + "%";
						
					}
					else {
						
						button1Element.style.right = 22 + "%";
						button2Element.style.right = 3 + "%";
						button3Element.style.right = 11 + "%";
						button4Element.style.right = 11 + "%";
						button5Element.style.right = 3 + "%";
						button6Element.style.right = 3 + "%";

						button1Element.style.bottom = 10 + "%";
						button2Element.style.bottom = 10 + "%";
						button3Element.style.bottom = 26 + "%";
						button4Element.style.bottom = 4 + "%";
						button5Element.style.bottom = 48 + "%";
						button6Element.style.bottom = 34 + "%";
						
					}
					
				} // end if ( !mouseControl ) {
				
			} // end function onWindowResize( event )
			
			
			
			function animate() {
				
				requestAnimationFrame( animate );
				
				frameTime = clock.getDelta();
				
				//elapsedTime = clock.getElapsedTime() % 1000;
				
				// reset flags
				cameraIsMoving = false;
				cameraJustStartedMoving = false;
				
				// check user controls
				if (mouseControl) {
					// movement detected
					if ( oldYawRotation != cameraControlsYawObject.rotation.y || 
					      oldPitchRotation != cameraControlsPitchObject.rotation.x ) {
						
						cameraIsMoving = true;
					}
					
					// save state for next frame
					oldYawRotation = cameraControlsYawObject.rotation.y;
					oldPitchRotation = cameraControlsPitchObject.rotation.x;
					
				} // end if (mouseControl)
			
				// if not playing on desktop, get input from the mobileJoystickControls
				if ( !mouseControl ) {

					newDeltaX = joystickDeltaX;
					
					if (newDeltaX) {
						
						mobileControlsMoveX = oldDeltaX - newDeltaX;
						// smooth out jerkiness if camera was sitting still 
						if (stillFlagX) {
							mobileControlsMoveX *= 0.1;
							stillFlagX = false;
						}
						// mobileJoystick X movement (left and right) affects camera rotation around the Y axis	
						cameraControlsYawObject.rotation.y += (mobileControlsMoveX) * 0.01;
					}
					
					newDeltaY = joystickDeltaY;
					
					if (newDeltaY) {
						
						mobileControlsMoveY = oldDeltaY - newDeltaY;
						// smooth out jerkiness if camera was sitting still
						if (stillFlagY) {
							mobileControlsMoveY *= 0.1;
							stillFlagY = false;
						}
						// mobileJoystick Y movement (up and down) affects camera rotation around the X axis	
						cameraControlsPitchObject.rotation.x += (mobileControlsMoveY) * 0.01;
					}
					
					// clamp the camera's vertical movement (around the x-axis) to the scene's 'ceiling' and 'floor',
					// so you can't accidentally flip the camera upside down
					cameraControlsPitchObject.rotation.x = Math.max( - PI_2, Math.min( PI_2, cameraControlsPitchObject.rotation.x ) );
					
					// save state for next frame
					oldDeltaX = newDeltaX;
					oldDeltaY = newDeltaY;
					
					// movement detected
					if ( newDeltaX || newDeltaY ) {
						
						cameraIsMoving = true;
					}
					else {
						stillFlagX = true;
						stillFlagY = true;
					}
					
					newPinchWidthX = pinchWidthX;
					newPinchWidthY = pinchWidthY;
					pinchDeltaX = newPinchWidthX - oldPinchWidthX;
					pinchDeltaY = newPinchWidthY - oldPinchWidthY;
					
					if( Math.abs(pinchDeltaX) > Math.abs(pinchDeltaY) ) {
						if (pinchDeltaX < -3) increaseFOV = true;
						if (pinchDeltaX >  3) decreaseFOV = true;
					}
					
					if( Math.abs(pinchDeltaY) >= Math.abs(pinchDeltaX) ) {
						if (pinchDeltaY >  1) increaseAperture = true;
						if (pinchDeltaY < -1) decreaseAperture = true;
					}
					
					// save state for next frame
					oldPinchWidthX = newPinchWidthX;
					oldPinchWidthY = newPinchWidthY;
					
				} // end if ( !mouseControl )
				
				// this gives us a vector in the direction that the camera is pointing,
				// which will be useful for moving the camera 'forward' and shooting projectiles in that direction
				controls.getDirection(cameraDirectionVector);
				cameraDirectionVector.normalize();
				controls.getUpVector(cameraUpVector);
				controls.getRightVector(cameraRightVector);
				
				// the following gives us a rotation quaternion (4D vector), which will be useful for 
				// rotating scene objects to match the camera's rotation
				worldCamera.getWorldQuaternion(cameraWorldQuaternion);
				
				// allow flying camera
				if ( (keyboard.pressed('W') || button3Pressed) && !(keyboard.pressed('S') || button4Pressed) ) {

					cameraControlsObject.position.add(cameraDirectionVector.multiplyScalar(camFlightSpeed * frameTime));
					cameraIsMoving = true;
				}
				if ( (keyboard.pressed('S') || button4Pressed) && !(keyboard.pressed('W') || button3Pressed) ) {

					cameraControlsObject.position.sub(cameraDirectionVector.multiplyScalar(camFlightSpeed * frameTime));
					cameraIsMoving = true;
				}
				if ( (keyboard.pressed('A') || button1Pressed) && !(keyboard.pressed('D') || button2Pressed) ) {

					cameraControlsObject.position.sub(cameraRightVector.multiplyScalar(camFlightSpeed * frameTime));
					cameraIsMoving = true;
				}
				if ( (keyboard.pressed('D') || button2Pressed) && !(keyboard.pressed('A') || button1Pressed) ) {

					cameraControlsObject.position.add(cameraRightVector.multiplyScalar(camFlightSpeed * frameTime));
					cameraIsMoving = true;
				}
				if ( keyboard.pressed('Q') && !keyboard.pressed('Z') ) {

					cameraControlsObject.position.add(cameraUpVector.multiplyScalar(camFlightSpeed * frameTime));
					cameraIsMoving = true;
				}
				if ( keyboard.pressed('Z') && !keyboard.pressed('Q') ) {

					cameraControlsObject.position.sub(cameraUpVector.multiplyScalar(camFlightSpeed * frameTime));
					cameraIsMoving = true;
				}
				if ( (keyboard.pressed('up') || button5Pressed) && !(keyboard.pressed('down') || button6Pressed) ) {
					
					increaseFocusDist = true;
				}
				if ( (keyboard.pressed('down') || button6Pressed) && !(keyboard.pressed('up') || button5Pressed) ) {
					
					decreaseFocusDist = true;
				}
				if ( keyboard.pressed('right') && !keyboard.pressed('left') ) {
					
					increaseAperture = true;
				}
				if ( keyboard.pressed('left') && !keyboard.pressed('right') ) {
					
					decreaseAperture = true;
				}
				
				if ( increaseFOV ) {
					worldCamera.fov ++;
					if (worldCamera.fov > 150)
						worldCamera.fov = 150;
					fovScale = worldCamera.fov * 0.5 * (Math.PI / 180.0);
					pathTracingUniforms.uVLen.value = Math.tan(fovScale);
					pathTracingUniforms.uULen.value = pathTracingUniforms.uVLen.value * worldCamera.aspect;
				
					cameraIsMoving = true;
					increaseFOV = false;
				}
				if ( decreaseFOV ) {
					worldCamera.fov --;
					if (worldCamera.fov < 1)
						worldCamera.fov = 1;
					fovScale = worldCamera.fov * 0.5 * (Math.PI / 180.0);
					pathTracingUniforms.uVLen.value = Math.tan(fovScale);
					pathTracingUniforms.uULen.value = pathTracingUniforms.uVLen.value * worldCamera.aspect;
					
					cameraIsMoving = true;
					decreaseFOV = false;
				}
				
				if (increaseFocusDist) {
					focusDistance ++;
					pathTracingUniforms.uFocusDistance.value = focusDistance;
					cameraIsMoving = true;
					increaseFocusDist = false;
				}
				if (decreaseFocusDist) {
					focusDistance --;
					if (focusDistance < 1)
						focusDistance = 1;
					pathTracingUniforms.uFocusDistance.value = focusDistance;
					cameraIsMoving = true;
					decreaseFocusDist = false;
				}
				
				if (increaseAperture) {
					apertureSize += 0.1;
					if (apertureSize > 20.0)
						apertureSize = 20.0;
					pathTracingUniforms.uApertureSize.value = apertureSize;
					cameraIsMoving = true;
					increaseAperture = false;
				}
				if (decreaseAperture) {
					apertureSize -= 0.1;
					if (apertureSize < 0.0)
						apertureSize = 0.0;
					pathTracingUniforms.uApertureSize.value = apertureSize;
					cameraIsMoving = true;
					decreaseAperture = false;
				}
				
				if ( cameraIsMoving ) {
					
					sampleCounter = 1.0;
					
					if ( !cameraRecentlyMoving ) {
						cameraJustStartedMoving = true;
						cameraRecentlyMoving = true;
					}
					
				}
				
				if ( !cameraIsMoving ) {
					
					sampleCounter += 1.0;
					cameraRecentlyMoving = false;
					
				}
					
				
				pathTracingUniforms.uRandomVector.value = randomVector.set( Math.random(), Math.random(), Math.random() );
				pathTracingUniforms.uCameraIsMoving.value = cameraIsMoving;
				pathTracingUniforms.uCameraJustStartedMoving.value = cameraJustStartedMoving;
				pathTracingUniforms.uSampleCounter.value = sampleCounter;
				screenOutputUniforms.uOneOverSampleCounter.value = 1.0 / sampleCounter;
				
				// CAMERA
				cameraControlsObject.updateMatrixWorld(true);			
				pathTracingUniforms.uCameraMatrix.value.copy( worldCamera.matrixWorld );
				
				cameraInfoElement.innerHTML = "FOV: " + worldCamera.fov + " / Aperture: " + apertureSize.toFixed(2) + " / FocusDistance: " + focusDistance + "<br>" + "Samples: " + sampleCounter;
				
				
				// RENDERING in 3 steps
				
				// STEP 1
				// Perform PathTracing and Render(save) into pathTracingRenderTarget
				// Read previous screenTextureRenderTarget to use as a new starting point to blend with
				renderer.render( pathTracingScene, worldCamera, pathTracingRenderTarget );	
				
				// STEP 2
				// Render(copy) the final pathTracingScene output(above) into screenTextureRenderTarget
				// This will be used as a new starting point for Step 1 above
				renderer.render( screenTextureScene, quadCamera, screenTextureRenderTarget );
				
				// STEP 3
				// Render full screen quad with generated pathTracingRenderTarget in STEP 1 above.
				// After the image is gamma corrected, it will be shown on the screen as the final accumulated output
				renderer.render( screenOutputScene, quadCamera );
						
				
				stats.update();
			
				
			} // end function animate()
			
		</script>
		
	</body>
</html>
